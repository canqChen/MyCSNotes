# 操作系统

## 基本概念

* 用户态和内核态
  * 用户态和内核态的区别
    * 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同
    * 用户态拥有最低的特权级，内核态拥有较高的特权级
    * **运行在用户态的程序不能直接访问操作系统内核数据结构和程序**
    * 操作系统的**数据都是存放于系统空间的**，**用户进程的数据是存放于用户空间的**。 分开来存放，就让系统的数据和用户的数据**互不干扰**，**保证系统的稳定性**
    * 分开存放，管理上很方便，而更重要的是，**将用户的数据和系统的数据隔离开**，就可以**对两部分的数据的访问进行控制**。这样就可以确保用户程序不能随便操作系统的数据，这样**防止用户程序误操作或者是恶意破坏系统**
  * [用户态和内核态可以通过指针传递数据吗？](http://blog.chinaunix.net/uid-26611973-id-3190018.html)
    * **用户态不能访问内核态的指针**
      - 为了实现内存的保护，**防止越界访问而造成受保护内存的被非法修改**，甚至造成系统的崩溃，这种直接传递数据指针来传递数据的方式是被禁止的。
    * 内核态可以访问用户态的指针(**有前提**)
      - **必须保证用户态虚拟空间的指针**（虚拟空间的地址），**已经分配物理地址**，**否则指针传入内核态中将不会引发缺页异常而报错**
    * **内核中访问用户进程的地址的时候用copy_from_user，而不是用memcpy直接拷贝**(或者说使用用户态指针)
      - copy_from_user主要是这个函数提供了两个功能
        - 对用户进程传过来的地址范围进行合法性检查
        - 当用户传来的地址没有分配物理地址时，定义了缺页处理后的异常发生地址，保证程序顺利执行
        - **对于用户进程访问虚拟地址，如果还未分配物理地址，就会触发内核缺页异常，接着内核会负责分配物理地址，并修改映射页表**。这个过程对于用户进程是完全透明的。**但是在内核空间发生缺页时，必须显式处理，否则会导致内核出现错误**
      - 直接使用memcpy时为什么没有出现异常
        - **只有用户传来的地址空间没有分配对应的物理地址时才会进行修复，如果用户进程之前已经使用过这段空间，代表已经分配了物理地址，自然不会发生缺页异常**
  * **两种状态转换**
    - **系统调用**
      - 用户进程**主动要求切换**到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作
    - **异常**
      - 当CPU在执行运行在用户态的程序时，发现了**某些事件不可知的异常**，这是会**触发由当前运行进程切换到处理此异常的内核相关程序**中，也就到了内核态，比如缺页异常
    - **外围设备中断**
      - 当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序
      - 比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等
* 程序计数器PC和指令指针寄存器IP
  * 程序计数器PC
    - 用指令事先编好的程序连续存放在内存程序区中，靠地址+1的方法连续取指执行”。在八位机8080CPU中是采用先取指后执行的串行操作的原理，而其中执行地址+1指令寻址的部件就是程序计数器PC。那么在程序的执行过程中，PC始终是指向下一条要执行的指令
    - 结论：PC中的地址就是需要转移、循环、调用子程序和中断子程序等操作时的断点
  * 指令指针寄存器IP
    - 在向上兼容的十六位机8086CPU中首先分为两个功能部件，即总线接口部件BIU和执行部件EU，BIU负责取指令，EU负责译码执行。并且当BIU执行指令排队栈中的六个字节装满后，（8088CPU是4个字节），EU开始从指令排队栈的出栈口，取指令进行译码执行，同时BIU并行操作向入栈口补充一条取指令命令
    - 指令指针IP则是指向下个条要取指的指令，而不是EU要执行的指令。而断点则应该是要执行的指令内存地址，而不是IP内的下一条要取指的指令地址
  * **PC是模型机中的概念，IP是实际使用的，调试时我们发现，IP实现的就是PC的功能**

## 进程管理

### 进程和线程

* **进程的概念**：**进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位**。通俗来说，**「进程就是程序的一次执行过程」**，程序是静态的，它作为系统中的一种资源是永远存在的。而进程是动态的，它是动态的产生，变化和消亡的，拥有其自己的生命周期

* 进程的组成

  * **进程控制块 PCB**。包含如下几个部分：
    - 进程描述信息
    - 进程控制和管理信息
    - 资源分配清单
    - CPU 相关信息
  * **数据段**。即进程运行过程中各种数据（比如程序中定义的变量）
  * **程序段**。就是程序的代码（指令序列）

* 进程上下文切换

  * 首先，将进程 A 的运行环境信息存入 PCB，这个运行环境信息就是进程的上下文（Context）
  * 然后，将 PCB 移入相应的进程队列
  * 选择另一个进程 B 进行执行，并更新其 PCB 中的状态为运行态
  * 当进程 A 被恢复运行的时候，根据它的 PCB 恢复进程 A 所需的运行环境

* 线程的概念：线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源

* **同一进程中线程资源共享情况**

  * 线程共享的资源包括：**进程代码段、进程的公有数据**(利用这些共享的数据，线程很容易的实现相互之间的通讯)、**进程打开的文件描述符**、**信号的处理函数**、**进程的当前目录和进程用户ID与进程组ID**
  * 线程不共享的资源包括：
    * **线程ID**：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程
    * **寄存器组的值**：由于线程间是并发运行的，**每个线程有自己不同的运行线索**，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复
    * **线程的堆栈**：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响
    * **错误返回码(errno)**：由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量
    * **线程的信号屏蔽码**：由于**每个线程所感兴趣的信号不同**，所以**线程的信号屏蔽码应该由线程自己管理**。**但所有的线程都共享同样的信号处理器**
    * **线程的优先级**：由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级

* 线程的优缺点

  * 优点：
    * 一个进程中可以同时存在多个线程，这些线程共享该进程的资源。**进程间的通信必须请求操作系统服务**（因为 CPU 要切换到内核态），开销很大。而同进程下的线程间通信，无需操作系统干预，开销更小。不过，需要注意的是：**从属于不同进程的线程间通信，也必须请求操作系统服务**
    * **线程间的并发比进程的开销更小**，**系统并发性提升**。同样，需要注意的是：**从属于不同进程的线程间切换，它是会导致进程切换的，所以开销也大**
  * 缺点：
    * 当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。举个例子，**对于游戏的用户设计，就不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程**

* **进程和线程的区别**

  * 拥有资源
    * 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
  * 调度
    * 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换
  * 系统开销
      * 进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。**进程切换需要分两步**：**切换页目录、刷新TLB以使用新的地址空间**；**切换内核栈和硬件上下文（寄存器）**；**而同一进程的线程间逻辑地址空间是一样的，线程切换时不需要切换页目录、刷新TLB，只需保存和设置少量寄存器内容，开销较小**
    * **进程在创建、销毁时开销比较大，而线程比较小**。进程创建的时候需要分配**虚拟地址空间、IO设备**等系统资源，而**销毁的的时候需要释放系统资源**；线程只需要**创建栈，栈指针，程序计数器，通用目的寄存器和条件码**等，**不需要创建独立的虚拟地址空间**等系统资源
  * 通信方面
    * **线程间可以通过直接读写同一进程中的数据进行通信**，但是进程通信需要借助 IPC
  
* 多进程和多线程

  * 多线程
    * **多线程就是指一个进程中同时有多个线程正在执行**
    * 多线程原因
      * 在一个程序中，**有很多的操作是非常耗时的**，如数据库读写操作，IO操作等，如果使用单线程，那么程序就必须等待这些操作执行完成之后才能执行其他操作。**使用多线程，可以在将耗时任务放在后台继续执行的同时，同时执行其他操作**，可以提高程序的效率
    * 多线程优点
      * 创建速度快，方便高效的数据共享
      * 共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术
      * 较轻的上下文切换开销：不用切换地址空间(页表)，不用更改CR3寄存器，不用刷新TLB
      * 提供非均质的服务：如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率
    * 多线程的缺点
      * 使用太多线程，是很耗系统资源，因为线程需要开辟内存。更多线程需要更多内存
      * 影响系统性能，因为操作系统需要在线程之间来回切换
      * 需要考虑线程操作对程序的影响，如线程挂起，中止等操作对程序的影响，某个线程的崩溃会导致整个程序崩溃
    * 多线程是异步的，但这不代表多线程真的是几个线程是在同时进行，实际上是**系统不断地在各个线程之间来回的切换**（因为系统切换的速度非常的快，所以给我们在同时运行的错觉）
    * 适用场景
      * **线程间有数据共享**，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）
      * 提供**非均质的服务**（有优先级任务处理）事件响应有优先
      * **单任务并行计算**，在非CPU Bound的场景下提高响应速度，降低时延
      * 与人**有IO交互的应用**，良好的用户体验（键盘鼠标的输入，立刻响应)
  * 多进程
    * 多进程就是指**计算机同时执行多个进程**，一般是同时运行多个软件
    * 优点
      * 编程相对容易，通常不需要考虑锁和同步资源的问题
      * 更强的容错性：比起多线程的一个好处是一个进程崩溃了不会影响其他进程
      * 有内核保证的隔离：数据和错误隔离
      * 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）
  * 应用场景
    * 多进程模型的优势是CPU
    * 多线程模型主要优势为**线程间切换代价较小**，因此**适用于I/O密集型的工作场景**，因此I/O密集型的工作场景经常会**由于I/O阻塞导致频繁的切换线程**。同时，**多线程模型也适用于单机多核分布式场景**
    * 多进程模型，**适用于CPU密集型**。同时，**多进程模型也适用于多机分布式场景中，易于多机扩展**
    * 进程线程间创建的开销不足作为选择的依据，因为一般我们都是使用线程池或者进程池，在系统启动时就创建了固定的线程或进程，不会频繁的创建和销毁
    * 首先，根据工作集（需要共享的内存）的大小来定；**如果工作集较大，就用多线程，避免cpu cache频繁的换入换出**；比如memcached缓存系统
    * 其次，选择的依据根据以上多线程适用的场景来对比自身的业务场景，是否有这样场景需求：**数据共享、提供非均质的服务，单任务拆散并行化等**；
      如果没有必要，或者多进程就可以很好的胜任，就**多用多进程，享受单线程编程带来便利**
  
* 高并发

  * 高并发指的是是一种系统运行过程中遇到的一种“**短时间内遇到大量操作请求**”的情况，主要发生在web系统集中大量访问或者socket端口集中性收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等

* 多线程与高并发的联系

  * 多线程只是在同/异步角度上解决高并发问题的其中的一个方法手段，是在同一时刻利用计算机闲置资源的一种方式
  * 多线程在高并发问题中的作用就是充分利用计算机资源，使计算机的资源在每一时刻都能达到最大的利用率，不至于浪费计算机资源使其闲置

* 操作系统的设计，**从进程和线程的角度来说**，可以归结为三点：

  - **以多进程形式，允许多个任务同时运行**
  - **以多线程形式，允许单个任务分成不同的部分运行**
  - **提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源**

* **fork，vfork，clone**

  * fork，vfork，clone**都是linux的系统调用**，这三个函数分别调用了**sys_fork、sys_vfork、sys_clone**，最终都调用了do_fork函数，**差别在于参数的传递和一些基本的准备工作不同，主要用来linux创建新的子进程或线程**（vfork创造出来的是线程）

    ![fork_vfork_clone](https://gitee.com/canqchen/cloudimg/raw/master/img/fork_vfork_clone.png)

  * fork

    * 函数调用成功：返回两个值； 父进程：返回子进程的PID；子进程：返回0；失败：返回-1

    * 写时复制技术（Copy-On-Write）：其基础的观念是，如果有多个调用者(callers)同时要求相同资源，他们会共同取得相同的指标指向相同的资源，直到某个调用者(caller)尝试修改资源时，系统才会真正复制一个副本(private copy)给该呼叫者，以避免被修改的资源被直接察觉到，这过程对其他的呼叫只都是通透的(transparently)。**此作法主要的优点是如果呼叫者并没有修改该资源，就不会有副本(private copy)被建立**

    * 现在Linux系统调用fork利用COW技术，**父进程和子进程共享页帧而不是复制页帧**。然而，只要页帧被共享，它们就不能被修改，即页帧被保护。**无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写**。原来的页帧仍然是写保护的：当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的

    * fork前后内存关系

      * fork()创建了一个心的进程(child)信进程几乎是调用进程(父进程的翻版),理解fork()的关键是，在完成对其调用之后，会产生2个进程，且每个进程都会从fork()的返回处开始执行

      * 这俩个进程将执行相同的程序段，但是拥有各自不同的堆段，栈段，数据段，每个子程序都可修改各自的数据段，堆段，和栈段

      * 调用fork()之后先执行哪个进程的是由Linux下专有文件/proc/sys/kernel/sched_child_runs_first的值来确定的(值为0父进程先执行，非0子进程先执行)

      * ##### fork后子进程只复制父进程的页表，父子进程的代码段是相同的，所以代码段是没必要复制的，因此内核将代码段标记为只读，这样父子进程就可以安全的共享此代码段了。fork之后在进程创建代码段时，新子进程的进程级页表项都指向和父进程相同的物理页帧

        <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/fork_mem.png" alt="fork_mem" style="zoom:75%;" />

      * **而对于父进程的数据段，堆段，栈段中的各页，由于父子进程要相互独立，所以我们采用写实复制的技术，来最大化的提高内存以及内核的利用率。刚开始，内核做了一些设置，令这些段的页表项指向父进程相同的物理内存页。调用fork之后，内核会捕获所有父进程或子进程针对这些页面的修改企图(说明此时还没修改)并为将要修改的页面创建拷贝。系统将新的页面拷贝分配给被内核捕获的进程，还会对子进程的相应页表项做适当的调整，现在父子进程就可以分别修改各自的上述段，不再互相影响了**

      * COW前

        <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/fork_cow1.png" alt="fork_cow1" style="zoom:75%;" />

      * COW后

        <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/fork_cow2.png" alt="fork_cow2" style="zoom:75%;" />

  * vfork

    * 是一个过时的应用，**vfork也是创建一个子进程，但是子进程共享父进程的空间**。**在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()**
    * **vfork最初是因为fork没有实现COW机制，而很多情况下fork之后会紧接着exec，而exec的执行相当于之前fork复制的空间全部变成了无用功，所以设计了vfork**。而现在fork使用了COW机制，唯一的代价仅仅是复制父进程页表的代价，所以vfork不应该出现在新的代码之中
    * **由vfork创建的子进程要先于父进程执行，子进程执行时，父进程处于挂起状态，子进程执行完，唤醒父进程**。除非子进程exit或者execve才会唤起父进程
    * vfork()用法与fork()相似，但是也有区别，具体区别归结为以下3点
      * **fork() 子进程拷贝父进程的数据段，代码段，vfork() 子进程与父进程共享数据段**
      * **fork() 父子进程的执行次序不确定，vfork()，保证子进程先运行**
      * vfork()保证子进程先运行，在它调用exec或_exit之后父进程才可能被调度运行。如果**在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁**

  * clone

    * 是Linux为创建线程设计的（虽然也可以用clone创建进程）。所以可以说**clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等**
    * clone函数功能强大，带了众多参数，它提供了一个非常灵活自由的常见进程的方法。因此由他创建的进程要比前面2种方法要复杂。**clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系**

    ```c++
    int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);
    
    // fn为函数指针，此指针指向一个函数体，即想要创建进程的静态程序（我们知道进程的4要素，这个就是指向程序的指针，就是所谓的“剧本", ）；
    // child_stack为给子进程分配系统堆栈的指针（在linux下系统堆栈空间是2页面，就是8K的内存，其中在这块内存中，低地址上放入了值，这个值就是进程控
    // 制块task_struct的值）；
    // arg就是传给子进程的参数一般为（0）；
    // flags为要复制资源的标志，描述你需要从父进程继承那些资源
    ```

    以下是flags可取的值

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/clone.jpg" alt="clone" style="zoom:80%;" />

  * clone和fork的区别：

    * clone和fork的调用方式很不相同，clone调用需要传入一个函数，该函数在子进程中执行

* clone和fork最大不同在于**clone不再复制父进程的栈空间，而是自己创建一个新的**。 （void *child_stack）也就是第二个参数，需要分配栈指针的空间大小，所以它不再是继承或者复制，而是全新的创造

### 协程

* 基本概念

  * **协程，英文Coroutines，是一种比线程更加轻量级的存在。**正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/corotines.jpg" alt="corotines" style="zoom:60%;" />

* 进程，线程，协程的上下文切换

  * 进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低
  * 线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等
  * 协程的切换者是用户（编程者或应用程序），**切换时机是用户自己的程序所决定的**。协程的切换内容是硬件上下文，**切换内存保存在用户自己的变量**（用户栈或堆）中。**协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高**
  * **协程是轻量级线程，拥有自己的寄存器上下文和栈**。**协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈**
  * 协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态

* 协程相比进程和线程的优势

  * 协程拥有极高的执行效率。因为**子程序切换不是线程切换，协程不是被操作系统内核所管理，而是由程序自身完全控制(完全运行在用户态)，因此，没有线程切换的开销**，和多线程比，线程数量越多，协程的性能优势就越明显
  * 不需要多线程的锁机制，因为**只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多**

* **应用场景**

  - I/O 密集型任务
    - 这一点与多线程有些类似，**但协程调用是在一个线程内进行的，是单线程，切换的开销小，因此效率上略高于多线程**
    - 当程序在执行 I/O 时操作时，CPU 是空闲的，此时可以充分利用 CPU 的时间片来处理其他任务。在单线程中，一个函数调用，一般是从函数的第一行代码开始执行，结束于 return 语句、异常或者函数执行（也可以认为是隐式地返回了 None ）
    - **有了协程，我们在函数的执行过程中，如果遇到了耗时的 I/O 操作，函数可以临时让出控制权，让 CPU 执行其他函数，等 I/O 操作执行完毕以后再收回控制权**

* 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是**多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能**

* python协程完成生产者-消费者问题例子（Python对协程的支持还非常有限，用在generator中的**yield**可以一定程度上实现协程）

  ```python
  import time
  
  def consumer():
      r = ''
      while True:
          n = yield r
          if not n:
              return
          print('[CONSUMER] Consuming %s...' % n)
          time.sleep(1)
          r = '200 OK'
  
  def produce(c):
      c.next()
      n = 0
      while n < 5:
          n = n + 1
          print('[PRODUCER] Producing %s...' % n)
          r = c.send(n)
          print('[PRODUCER] Consumer return: %s' % r)
      c.close()
  
  if __name__=='__main__':
      c = consumer()
      produce(c)
  ```

  注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：

  1. 首先调用c.next()启动生成器；
  2. 然后，一旦生产了东西，通过c.send(n)切换到consumer执行；
  3. consumer通过yield拿到消息，处理，又通过yield把结果传回；
  4. produce拿到consumer处理的结果，继续生产下一条消息；
  5. produce决定不生产了，通过c.close()关闭consumer，整个过程结束。

  整个流程**无锁**，由一个线程执行，produce和consumer**协作完成任务**，所以称为“协程”，而非线程的抢占式多任务

* 支持协程的编程语言

  * **Lua语言**
  * **Python语言**
  * **Go语言**
  * **Java语言(Kilim框架)**

### 同步互斥

* [详见1](https://www.jianshu.com/p/6526078a1fab)

* [详见2](https://blog.csdn.net/qicheng777/article/details/77432129)

* 生产者-消费者问题(C++11实现)

  ```c++
  #include <thread>
  #include <mutex>
  #include <condition_variable>
  #include <queue>
  #include <cstdlib>
  #include <iostream>
  
  std::mutex mtx;
  std::condition_variable prodCond;
  std::condition_variable consCond;	
  const int QSIZE = 50;
  std::queue<int> blockQueue;
  volatile bool isClose = false;
  
  void producer(int id){
      while(!isClose){
          long item = 1 + rand() % 99;  // produce item in range [1,100] 
          std::unique_lock<std::mutex> locker(mtx);
          while(blockQueue.size() >= QSIZE)
              prodCond.wait(locker);		// 释放锁，等待，醒来时获得锁
          std::cout<<"Producer " << id <<" produces item "<< item <<std::endl;
          blockQueue.push(item);	// insert item
          locker.unlock();
          consCond.notify_all();
      }
      std::cout<<"Producer " << id <<" finished!"<<std::endl;
  }
  
  void consumer(int id){
      while(!isClose){
          std::unique_lock<std::mutex> locker(mtx);
          while(blockQueue.size() == 0)
              consCond.wait(locker);	
          int item = blockQueue.front();	// consumes item
          std::cout<<"Consumer " << id <<" cosumes item "<< item << std::endl;
          blockQueue.pop();			// remove item
          locker.unlock();
          prodCond.notify_all();
      }
      std::cout<<"Consumer " << id <<" finished!"<<std::endl;
  }
  
  int main(int argc, char * argv[]){
      const int num = 2;
      std::vector<std::thread> producers(num);
      std::vector<std::thread> consumers(num);
      
      for(int i = 0; i < num; i++){
          producers[i] = std::thread(producer, i+1);
          consumers[i] = std::thread(consumer, i+1);
      }
  	
      sleep(1);
      
    	isClose = true;
      
      for(int i = 0; i < num; i++){
          producers[i].join();
          consumers[i].join();
      }
      
      return 0;
  }
  ```

* 读者-写者问题

  ```c++
  #include <thread>
  #include <mutex>
  #include <iostream>
  
  std::mutex mtx;
  std::mutex cntMtx;
  
  size_t readCount = 0;  // std::atomic<size_t> readCount;
  
  volatile bool isClose = false;
  
  void reader(int id){
    while(!isClose){
          std::unique_lock<std::mutex> cntLock(cntMtx);	// 用于读者互斥计数
          readCount++;
          if(readCount == 1)
          	mtx.lock();			// 第一个读者，加锁
  		cntLock.unlock();
          
          std::cout<<"Reader " << id <<" reads "<< item <<std::endl;
          
          cntLock.lock();
          readCount--;
          if(readCount == 0)		// 已无读者，解锁唤醒写者
          	mtx.unlock();
          cntLock.unlock();
      }
      std::cout<<"Reader " << id <<" finished!"<<std::endl;
  }
  
  void writer(int id){
    while(!isClose){
          mtx.lock();		// 读写互斥锁
          
          std::cout<<"Writer " << id <<" writes "<< item << std::endl;
          
        	mtx.unlock();	// 解锁
      }
      std::cout<<"Writer " << id <<" finished!"<<std::endl;
  }
  
  int main(int argc, char * argv[]){
      const int num = 2;
      std::vector<std::thread> writers(num);
      std::vector<std::thread> readers(num);
      
      for(int i = 0; i < num; i++){
          writers[i] = std::thread(writer, i+1);
      	readers[i] = std::thread(reader, i+1);
      }
  	
      sleep(1);
      
    	isClose = true;
      
      for(int i = 0; i < num; i++){
          writers[i].join();
        readers[i].join();
      }
    
      return 0;
  }
  ```

### 死锁

* 死锁

  * 死锁是多线程中最差的一种情况，**多个线程相互占用对方的资源的锁，而又相互等对方释放锁**，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁

* 死锁检测与避免

  * **产生死锁的四大必要条件**

    * **资源互斥/资源不共享**：每个资源要么已经分配给了一个进程，要么是可用的，只有这两种状态，资源不可以被共享使用，所以所谓的互斥是指：资源不共享，如果被使用，只能被一个进程使用
    * **占有和等待/请求并保持**：已经得到资源的进程还能继续请求新的资源
    * **资源不可剥夺**：当一个资源分配给了一个进程后，其它需要该资源的进程不能强制性获得该资源，除非该资源的当前占有者显示地释放该资源
    * **环路等待**：死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，环路上的每个进程都在等待下一个进程所占有的资源

  * 预防死锁

    * 预防死锁的发生**只需破坏死锁产生的四个必要条件之一**即可
    * 下面的方法开销非常之大，目前没有一个操作系统可以实现
      * **破坏互斥条件**：如果允许系统资源都能共享使用，则系统不会进入死锁状态； **缺点**：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，**破坏互斥条件而预防死锁的方法不太可行**，而且在有的场合应该保护这种互斥性
      * **破坏请求并保持条件**：釆用预先静态分配方法，即**进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行**。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。**缺点**：系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会**导致“饥饿”**现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行
      * **破坏不可剥夺条件**：当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。**缺点**：该策略实现起来比较复杂，**释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量**。*这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源*
      * **破坏循环等待条件**：为了破坏循环等待条件，可釆用顺序资源分配法。首先**给系统中的资源编号**，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。**缺点**： 这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦
    * 因此，目前使用的方法是避免死锁，而不是预防死锁

  * 避免死锁的算法

    * 判断“系统安全状态”法：**在进行系统资源分配之前，先计算此次资源分配的安全性**。若此次分配不会导致系统进入不安全状态，则将资源分配给**进程； 否则，让进程**等待

      ![safe_status](https://gitee.com/canqchen/cloudimg/raw/master/img/safe_status.png)

      * **图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数**。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的
      * 定义：**如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的**
      * 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比

    * 银行家算法

      * 申请的贷款额度不能超过银行现有的资金总额
      * 分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额
      * 暂时不能满足客户申请的资金额度时，在有限时间内给予贷款
      * 客户要在规定的时间内还款

    * 单个资源银行家算法

      * 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，**算法要做的是判断对请求的满足是否会进入不安全状态**，如果是，就拒绝请求；否则予以分配

        ![bank](https://gitee.com/canqchen/cloudimg/raw/master/img/bank.png)

        上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态

    * 多个资源银行家算法

      ![multi_bank](https://gitee.com/canqchen/cloudimg/raw/master/img/multi_bank.png)

      * 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0
      * 检查一个状态是否安全的算法如下：
        * 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的
        * 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中
        * 重复以上两步，直到所有进程都标记为终止，则状态时安全的
      * 如果一个状态不是安全的，需要拒绝进入这个状态

* 活锁

  * 活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁

* 饥饿

  * 优先级高的线程能够插队并优先执行，这样如果**优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行**，这就是饥饿。当然还有一种饥饿的情况，**一个线程一直占着一个资源不放而导致其他线程得不到执行**，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源

* 无锁

  * 无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功

### CAS技术

* 概念

  * 比较并交换(compare and swap, CAS)，是原子操作的一种。**在多线程没有锁的状态下，可以保证多个线程对同一个值的更新**。CAS可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性，产生的数据不一致问题。该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值

* 原理

  * 执行函数：CAS(V，E，N) ，CAS有3个操作数，内存值`V`，旧的期望值 `E`，要修改的新值 `N`。当且仅当预期值`E`和内存值`V`相同时（比较），它就认为这个期间没有人来访问过这个贡献资源，所以就把`V`值改为新值`N`（交换）
  * **如果多个线程同时使用CAS操作一个变量的时候，只有一个线程能够修改成功。其余的线程提供的期望值已经与共享变量的值不一样了，所以均会失败**
  * 由于CAS操作属于乐观派，它总是认为自己能够操作成功，所以操作失败的线程将会再次发起操作，而不是被OS挂起。所以说，即使CAS操作没有使用同步锁，其它线程也能够知道对共享变量的影响
  * 因为其它线程没有被挂起，并且将会再次发起修改尝试，所以无锁操作即CAS操作天生免疫死锁
  * **CAS是系统原语，CAS操作是一条CPU的原子指令（cmpxchg），这个指令是给数据总线进行加锁，所以不会有线程安全问题**

* 特点

  * CAS结合`volatile`可以实现无锁并发，**适用于线程数少，多核CPU场景下**(线程数不要超过CPU核数)
  * CAS是**基于乐观锁实现**（本身并无锁，区别于synchronized）
  * CAS体现的是**无锁并发、无阻塞并发**
    * CAS的原子性 + `volatile`的可见性，不断的【比较与交换】保证线程安全
    * 没有用锁来保证线程安全，所以不会阻塞
    * 如果竞争激烈，会导致**重试**频繁发生，效率下降

* 自旋–比较和交换

  * **自旋：** 就是不停的判断比较，看能否将值交换

  * 多个线程在访问共享资源的时候，会产生同步问题，所以需要加锁来保证安全。但是，一旦加了锁，同一时刻只能有一个线程获取锁对象，效率自然变低了

  * 不加锁的情况下来修改值，CAS是怎么自旋如下图

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/cas.jpg" alt="cas" style="zoom:67%;" />

  * 现在`Data`中存放的是`num=0`，线程A将`num=0`拷贝到自己的工作内存中计算（做+1操作）`E=0`，计算的结果为`V=1`

  * 由于是在多线程不加锁的场景下操作，所以可能此时`num`会被别的线程修改为其他值。此时需要再次读取`num`看其是否被修改，记再次读取的值为`N`

  * 如果被修改，即`E != N`，说明被其他线程修改过。那么此时工作内存中的E已经和主存中的`num`不一致了，根据EMSI协议，保证安全需要重新读取`num`的值。直到`E = N`才能修改

  * 如果没被修改，即`E = N`，说明没被其他线程修改过。那么将工作内存中的`E=0`改为`E=1`，同时写回主存。将`num=0`改为`num=1`

* CAS三大问题

  * **ABA问题**
    * CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题
    * 常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么`A-B-A` 就会变成`1A-2B-3A`，由于每个过程值都会有对应的版本，所以我们在修改过程中需要传入期望版本和当前的值，数据库的多版本并发控制也类似
    * 添加时间戳：添加世时间戳也可以解决。查询的时候把时间戳一起查出来，对的上才修改并且更新值的时候一起修改更新时间，这样也能保证，方法很多但是跟版本号都是异曲同工之妙
  * 无限循环问题（自旋）
    * 如果CAS不成功，则会原地自旋，如果长时间自旋会**给CPU带来非常大且没必要的开销**
    * 可以使用java8中的LongAdder，分段CAS和自动分段迁移
    * 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率
  * 只能保证一个共享变量的原子操作
    * 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是**把多个共享变量合并成一个共享变量来操作**。比如有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用CAS来操作
    * 可以用AtomicReference (java)，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用AtomicReference的CAS操作可以解决并发冲突问题

### IPC

* 进程间通信(IPC)，[详见](https://www.cnblogs.com/zgq0/p/8780893.html)

  * 管道：通常指无名管道，是 UNIX 系统IPC最古老的形式

    * 它是**半双工**的（即数据只能在一个方向上流动），具有固定的读端和写端
    * 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
    * 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并**不属于其他任何文件系统**，并且**只存在于内存**中
    * 原型

    ```c
    1 #include <unistd.h>
    2 int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
    ```

  * FIFO：也称为命名管道，它是一种文件类型

    * FIFO可以在无关的进程之间交换数据，与无名管道不同
    * FIFO有路径名与之相关联，它以一种**特殊设备文件形式存在于文件系统**中
    * FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。**在数据读出时，FIFO管道中同时清除数据，并且“先进先出”**
    * 原型

    ```c
    1 #include <sys/stat.h>
    2 // 返回值：成功返回0，出错返回-1
    3 int mkfifo(const char *pathname, mode_t mode);
    ```

* 其中的` mode `参数与`open`函数中的 `mode `相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它

  * 当 open 一个FIFO时，是否设置非阻塞标志（`O_NONBLOCK`）的区别：
    * 若没有指定`O_NONBLOCK`（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 `open` 要阻塞到某个其他进程为读而打开它
    * 若指定了`O_NONBLOCK`，则只读` open `立即返回。而只写` open `将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其`errno`置`ENXIO`。

* 消息队列：**是消息的链接表，存放在内核中**。一个消息队列由一个标识符（即队列ID）来标识

  * 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级
    * 消息队列独立于发送与接收进程。**进程终止时，消息队列及其内容并不会被删除**
    * **消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取,也可以按消息的类型读取**
    * 原型

  ```c
    1 #include <sys/msg.h>
    2 // 创建或打开消息队列：成功返回队列ID，失败返回-1
    3 int msgget(key_t key, int fslag);
    4 // 添加消息：成功返回0，失败返回-1
    5 int msgsnd(int msqid, const void *ptr, size_t size, int flag);
    6 // 读取消息：成功返回消息数据的长度，失败返回-1
    7 int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
    8 // 控制消息队列：成功返回0，失败返回-1
    9 int msgctl(int msqid, int cmd, struct msqid_ds *buf);
  ```

  * 在以下两种情况下，`msgget`将创建一个新的消息队列：

    - 如果没有与键值key相对应的消息队列，并且flag中包含了`IPC_CREAT`标志位。
    - key参数为`IPC_PRIVATE`。

    * 函数`msgrcv`在读取消息队列时，`type`参数有下面几种情况：
      * `type == 0`，返回队列中的第一个消息
      * `type > 0`，返回队列中消息类型为 `type` 的第一个消息
      * `type < 0`，返回队列中消息类型值小于或等于` type `绝对值的消息，如果有多个，则取类型值最小的消息
    * 可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把` type` 看做优先级的权值

* [信号(signal)](https://blog.csdn.net/h___q/article/details/84245317)

  * 信号是一种比较复杂的通信方式，**用于通知接收进程某个事件已经发生**

  * 程序不可捕获、阻塞或忽略的信号有：**SIGKILL(9)，SIGSTOP(19)**

    - 它们向超级用户提供一种使进程终止或停止的可靠方法
    - 如果忽略某些由硬件异常产生的信号（例如非法存储访问或除以0），则进程的行为是未定义的

  * 常见信号表

    ![signal_tab](https://gitee.com/canqchen/cloudimg/raw/master/img/signal_tab.jpg)

  * 信号产生方式

    * 键盘产生

      * 如ctrl+c，ctrl+z，ctrl+/等

    * 程序异常

      * 除0错误。除0错误会导致硬件错误
      * core dumped（核心转储）：**当进程异常退出时，操作系统会将该进程发生异常退出之前在内存中的数据存储至硬盘上**
      * **2、9号信号不会产生core文件**

    * 使用kill命令

      * **kill 预设的信息为 SIGTERM(15)，可将指定程序终止**。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看

      ```shell
      kill [-s <信息名称或编号>][程序]　或　
      kill [-l <信息编号>]
      
      -l <信息编号> 　若不加<信息编号>选项，则 -l 参数会列出全部的信息名称
      -s <信息名称或编号> 　指定要送出的信息
      [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号
      
      最常用的信号是：
      1 (HUP)：重新加载进程
      9 (KILL)：杀死一个进程
      15 (TERM)：正常停止一个进程
      ```

    * 通过系统调用接口给特定进程发送信号

      ```c++
      #include<signal.h>
      
      int kill(pid_t pid, int signo);
      //向特定进程发送特定信号;成功返回0;失败返回-1
      
      int raise(int signo);
      //向当前进程发送特定信号;成功返回0;失败返回-1
      
      #include<stdlib.h>
      void abort(void);
      //使当前进程收到信号而异常终止；就像exit()函数一样，abort()函数总是会成功的，所以没有返回值
      ```

    * 由软件条件发送信号

      * SIGPIPE：SIGPIPE是一种由软件条件产生的信号，**当一个管道的读端被关闭时，这时候操作系统就会检测到该管道中写入的数据不会在有人来管道内读文件了，操作系统会认为该管道的存在会造成内存资源的极大浪费，则操作系统就会向写端对应的目标进程发送SIGPIPE信号**
      
      * 定时器
      
        ```c++
      #include<unistd.h>
        unsigned int alarm(unsigned int seconds);
        //调用alarm函数可以对当前进程设置一个闹钟，也就是告诉操作系统在seconds秒之后对当前进程发送SIGALRM信号，该信号的默认处理动作是终止当前进程
        ```
    
  * **信号集操作函数**

    ```c++
    #include<signal.h>
    
    //注意：在使用sigset_t类型的变量前，一定要调用sigemptyset或sigfillset进行初始化，使信号集处于某种确定的状态，初始化之后就可以调用sigaddset或sigdelset在信号集中添加或删除某种有效信号
    
    int sigemptyset(sigset_t *set);
    //初始化set所指向的信号集，使其中所有信号对应的比特位清零，表示该信号集不包含任何信号
    
    int sigfillset(sigset_t *set);
    //初始化set所指向的信号集，将其中所有信号对应的比特位置1，表示该信号集的有效信号包括系统支持的所有信号
    
    int sigaddset(sigset_t *set, int signo);
    //表示将set所指向的信号集中的signo信号置1
    
    int sigdelset(sigset_t *set, int signo);
    //表示将set所指向的信号集中的signo信号清零
    
    int sigismember(const sigset_t *set, int signo);
    //用来判断set所指向的信号集的有效信号中是否包含signo信号，包含返回1，不包含返回0，出错返回-1
    
    int sigpending(sigset_t *set);
    // 获取进程的pending信号集
    // 成功返回0；失败返回-1
    ```

  * **设置/修改进程的信号屏蔽字（block表）**

    ```c++
    #include<signal.h>
    
    int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
    
    /*
      int how：
      	SIG_BLOCK：set包含了用户希望添加到当前信号屏蔽字的信号，即就是在老的信号屏蔽字中添加上新的信号。相当于：mask=mask|set
      	SIG_UNBLOCK：set包含了用户希望从当前信号屏蔽字中解除阻塞的信号，即就是在老的信号屏蔽字中取消set表中的信号。相当于：mask=mask&~set
      	SIG_SETMASK：设置当前进程的信号屏蔽字为set所指向的信号集。相当于：mask=set
      const sigset_t *set：
      	将要设置为进程block表的信号集
      sigset_t *oset：
      	用来保存进程旧的block表
      	若无需保存进程旧的block表，传递空指针即可
    */
    ```

  * **自定义信号处理方式**

    ```c++
    #include<signal.h>
    
    struct sigaction
    {
        void (*sa_handler)(int);	//指向信号处理对应的函数
        void (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t sa_mask; //当在处理所收到信号时，想要附带屏蔽的其他普通信号，当不需要屏蔽其他信号时，需要使用sigemptyset初始化sa_mask
        int sa_flags;
        void (*sa_restorer)(void);
    };
    
    int sigaction(int signo, const struct sigaction *act, struct sigaction *oact);
    /*
    int signo：
    	指定的信号编号
    const struct sigaction *act：
    	若该act指针非空，则根据act指针来修改进程收到signo信号的处理动作
    struct sigaction *oact：
    	若oact指针非空，则使用oact来保存信号旧的处理动作
    */
    ```

  * **信号处理过程**

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/sig_cap.jpg" alt="sig_cap" style="zoom:80%;" />

  * 信号接收

    * **接收信号的任务是由内核代理的，但内核接收到信号后，会将其放到对应进程的PCB的未决信号集中，同时向进程发送一个中断，使其陷入内核态**
  * **此时信号只是在未决信号集中，对进程来说是不知道信号到来的**
    
  * 信号的检测

    * 进程陷入内核后，**有两种场景会对信号集进行检测**：
      * 进程**从内核态返回到用户态前进行信号检测**
      * 进程在内核态中，**从睡眠状态被唤醒的时候进行信号检测**
    * 当发现有新信号后，便会进入下一步，信号处理

  * 信号的处理

    * 如果用户未注册信号处理函数，则内核按照信号的默认处理方式处理
    * **如果用户注册了信号处理函数，则信号处理函数是运行在用户态的**，调用处理函数前，**内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器(eip)将其指向信号处理函数**
    * **接下来进程返回到用户态中，执行相应的信号处理函数**
    * **信号处理函数执行完成后，还需要返回内核态，检查是否还有其他信号未处理**
    * **如果所有信号都处理完成了，就会将内核栈回复(从用户栈的备份拷贝回来)，同时恢复指令寄存器(eip)将其指向中断前的运行位置，最后回到用户态继续执行进程**
    * 如果同时有多个信号到达，处理流程为上面1，2，3，4步骤间重复进行，直到所有信号处理完毕

  * **处理信号的时机**

    * 进程收到一个信号时，**并不会立即就去处理这个信号，而是先将收到的信号保存下来，并在合适的时候对信号进行处理**，**操作系统会在进程进入了内核态并从内核态返回用户态时，检测进程中可以进行处理的信号，并进行处理**

      ##### 用户写好的代码会在什么情况下进入内核态呢？

      - 调用系统调用接口
      - 异常
      - 中断

* 信号量：与已经介绍过的 IPC 结构不同，它是**一个计数器**。信号量**用于实现进程间的互斥与同步，而不是用于存储进程间通信数据**

  * 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
    * 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作
    * 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数
    * 支持信号量组
    * 原型

  ```c
  #include <sys/sem.h>
  // 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
  int semget(key_t key, int num_sems, int sem_flags);
  // 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
  int semop(int semid, struct sembuf semoparray[], size_t numops);  
  // 控制信号量的相关信息
  int semctl(int semid, int sem_num, int cmd, ...);
  ```

  * 当`semget`创建新的信号量集合时，必须指定集合中信号量的个数（即`num_sems`），通常为1； 如果是引用一个现有的集合，则将`num_sems`指定为 0 。在`semop`函数中，`sembuf`结构的定义如下：

  ```c
  struct sembuf 
  {
      short sem_num; // 信号量组中对应的序号，0～sem_nums-1
      short sem_op;  // 信号量值在一次操作中的改变量
      short sem_flg; // IPC_NOWAIT, SEM_UNDO
  }
  ```

  * 其中` sem_op` 是一次操作中的信号量的改变量：

    - 若`sem_op > 0`，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们
      - 若`sem_op < 0`，请求 `sem_op `的绝对值的资源
        - 如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。
        - 当相应的资源数不能满足请求时，这个操作与`sem_flg`有关
          - `sem_flg `指定`IPC_NOWAIT`，则semop函数出错返回`EAGAIN`
          - `sem_flg` 没有指定`IPC_NOWAIT`，则将该信号量的`semncnt`值加1，然后进程挂起直到下述情况发生：
            1. 当相应的资源数可以满足请求，此信号量的`semncnt`值减1，该信号量的值减去sem_op的绝对值。成功返回；
            2. 此信号量被删除，函数`smeop`出错返回`EIDRM`；
            3. 进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的`semncnt`值减1，函数`semop`出错返回`EINTR`
      - 若`sem_op == 0`，进程阻塞直到信号量的相应值为0：
        - 当信号量已经为0，函数立即返回。
        - 如果信号量的值不为0，则依据`sem_flg`决定函数动作：
          - `sem_flg`指定`IPC_NOWAIT`，则出错返回`EAGAIN`。
          - `sem_flg`没有指定`IPC_NOWAIT`，则将该信号量的`semncnt`值加1，然后进程挂起直到下述情况发生：
            1. 信号量值为0，将信号量的`semzcnt`的值减1，函数`semop`成功返回；
            2. 此信号量被删除，函数`smeop`出错返回`EIDRM`；
            3. 进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的`semncnt`值减1，函数`semop`出错返回`EINTR`

    - 在`semctl`函数中的命令有多种，这里就说两个常用的：
      - `SETVAL`：用于初始化信号量为一个已知的值。所需要的值作为联合`semun`的`val`成员来传递。在信号量第一次使用之前需要设置信号量。
      - `IPC_RMID`：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。

* **共享内存**：指两个或多个进程共享一个给定的存储区

  * **共享内存是最快的一种 IPC，因为进程是直接对内存进行存取**
  * **因为多个进程可以同时操作，所以需要进行同步**
  * **信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问**
  * **共享内存实现原理**：共享内存是通过**把同一块内存分别映射到不同的进程空间**中实现进程间通信。而共享内存本身不带任何互斥与同步机制，但当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以，在实际中，同步与互斥机制需要用户来完成
  * 在**/proc/sys/kernel/**目录下，记录着共享内存的一些限制，如一个共享内存区的**最大字节数shmmax**，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做
  * 共享内存使用
    * 进程必须首先分配它
    * 随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中
    * 当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块

  * 原型

  ```c
  #include <sys/shm.h>
  // 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1
  int shmget(key_t key, size_t size, int flag);
  // 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1
  void *shmat(int shm_id, const void *addr, int flag);
  // 断开与共享内存的连接：成功返回0，失败返回-1
  int shmdt(void *addr); 
  // 控制共享内存的相关信息：成功返回0，失败返回-1
  int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
  ```

  * 当用`shmget`函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 
    * **当一段共享内存被创建以后，它并不能被任何进程访问。必须使用`shmat`函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问**
    * `shmdt`函数是用来断开`shmat`建立的连接的。注意，**这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已**
    * `shmctl`函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是`IPC_RMID`（从系统中删除该共享内存）
  * **mmap实现共享内存**
    * mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，**当然mmap()实现共享内存也是其主要应用之一**
    * **mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存**。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再 调用read()，write（）等操作。
    * mmap并不分配空间, 只是将文件映射到调用进程的地址空间里, 然后你就可以用memcpy等操作写文件，而不用write()了。写完后用msync()同步一下，你所写的内容就保存到文件里了。 **不过这种方式没办法增加文件的长度**，**因为要映射的长度在调用mmap()的时候就决定了**
    * 简单说就是把一个文件的内容在内存里面做一个映像，内存比磁盘快些

### 线程间通信

* 线程是共享同一进程的地址空间的，拟线程间的通信将会很容易，直接就可以通过全局变量来交换数据。但这种访问的便利性也带来了一些风险，通常当有多个线程访问相同的共享数据时需要**同步**或**互斥锁**

* 线程同步：同步指的是多个任务按照事先约定的顺序先后地完成一件事情

* 线程间同步机制

  * 互斥量

    * 互斥量是最基础的加锁原语。**确保同一时间只有一个线程访问数据**，**通过在访问共享资源前对互斥量加锁，阻塞其他试图再次加锁的线程直到互斥锁被释放**。互斥的具体实现有多种方法，例如开关中断，使用原子的机器指令

    * 互斥量常用函数

      ```c++
      #include <pthread.h>
      pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;
      // 定义互斥量
      int pthread_mutex_init(pthread_mutex_t *__mutex,__const pthread_mutexattr_t *__mutexattr);
      // 初始化互斥量，使用第二互斥量来初始化第一个互斥量，如果第二个为空，则使用默认参数初始化互斥量,也可以使用宏来初始化
      
      int pthread_mutex_destroy(pthread_mutex_t *__mutex);
      // 功能：销毁互斥量
      // 注意：互斥量是一个结构体，里面有成员是指针，指向了堆内存数据，需要显式初始化函数以及销毁函数。
      // 如果使用堆内存存储互斥量，需要在调用了销毁函数后，再进行free
      
      int pthread_mutex_lock(pthread_mutex_t *__mutex);
      // 功能：锁定互斥量，当互斥量是锁定状态，此函数则阻塞（直到互斥量在其它线程中解锁，调用者者线程加锁成功才返回）
      // 注意：互斥量一旦加锁，只有它自己能解
      
      int pthread_mutex_trylock(pthread_mutex_t *__mutex);
      //  功能：尝试锁定互斥量，能锁就锁，不能锁就立即返回，不阻塞线程
      
      int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,const struct timespec *__restrict_abstime);
      // 功能：在指定时间内锁定一个互斥量(使用的系统时间)。
      struct timespec
      {
        	time_t tv_sec;        /* Seconds.  */
        	long int tv_nsec;       /* Nanoseconds.  */
      };
      
      int pthread_mutex_unlock (pthread_mutex_t *__mutex);
      // 功能：解锁
      ```

  * **自旋锁** 

    * 自旋锁与互斥量类似，在任何时刻同样只能有一个线程访问对象。但是**当获取锁操作失败时，不会进入睡眠，而是会在原地自旋**，循环检测锁的保持者是否释放，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源

  * **屏障** 

    * 屏障主要用于多个线程之间的并行工作的协调。屏障允许每个线程等待，直到所有的合作线程都达到某个点，然后从该点继续执行

  * 信号量

    * 信号量可以决定线程当前是继续运行还是等待

    * 信号量代表某一类资源，其值表示系统中该资源的数量。因此它是一个非负数的值

    * 信号量是一个受保护的变量，只能通过三种操作来访问：

      * 初始化
      * P操作（申请资源）
        * 当进行P操作时，它会去**判断当前信号量的值是否大于0**，**若是，则申请P操作的任务继续运行，同时信号量的值减一**。**若否，则阻塞**
      * V操作（释放资源）
        * V操作则是**先让信号量的值加一**，**再判断当前是否有正在等待资源的任务以让它继续运行**

    * pthread库信号量常用函数

      ```c++
      #include <semaphore.h>
      
      int sem_init(sem_t *sem, int pshared, unsigned int value); // 信号量的初始化。
      // 执行成功返回0，失败返回EOF，并设置 errno。第一个参数指向要初始化的信号量对象第二个参数表示是进程间还是线程间，0表示线程间，1表示进程间。第三个参数则是信号量的初值了
      
      int sem_wait(sem_t *sem); // P操作
      
      int sem_post(sem_t *sem); // V操作
      ```

  * 条件变量

    * 条件变量是一种“事件通知机制”，它本身不提供、也不能够实现“互斥”的功能。因此，条件变量通常（也必须）配合互斥量来一起使用，其中互斥量实现对“共享数据”的互斥（即同步），而条件变量则去执行 “通知共享数据状态信息的变化”的任务。比如通知队列为空、非空，或任何其他需要由线程处理的共享数据的状态变化

    * 条件变量原则

      * 等待条件变量总是返回被锁住的互斥量
      * 条件变量的作用是发信号，而不是互斥
      * 一个条件变量应该只与一个“状态描述（也有称呼为“谓词”，所谓谓词，即：描述代码所需不变量的状态的语句）”相关联
      * 所有并发地（同时）去等待一个条件变量的线程必须指定同一个“互斥量”
      * 条件变量提供了“信号单播（signal，注意：这里的所谓信号并非Linux下的SIGxxx）”和“信号广播(broadcast)”两种方式，**基于更安全、高效等因素，优先考虑使用“广播信号”方式**
      * 注意区分signal和broadcast：“**broadcast通常用于表明状态变化，signal通常用于表示资源可用**”
      * 线程发信号或广播条件变量时候看到的内存数据，同样也可以被唤醒的其他线程看到。而在发信号或广播之后写入内存的数据不会被唤醒的线程看到，即使写操作发生在线程被唤醒之前
      * 一个内存地址一次只能保持一个值；不要让线程竞争以优先获得访问权
      * 在等待线程醒来时候，检查其“状态”是否为真是个不错的主意；**同时应该总是在一个循环中等待条件变量**(防止伪唤醒，spurious wakeup)
      * 条件变量是程序用来等待某个“状态”为真的机制

    * 条件变量常用函数

      ```c++
      #include <pthread.h>
      
      /**@fn            pthread_cond_init
       * @brief         初始化条件变量cond(attr创建可选的条件变量属性)
       * @param[in]     pthread_cond_t *cond 条件变量   
       * @param[in]     pthread_condattr_t *attr 条件变量高级属性
       * @param[out]    NONE
       * @description   常见错误码：[ENOMEN]内存不足,[EAGAIN]资源不足,[EBUSY]cond已经初始化,[EINVAL]attr无效
       * @return        int
      **/
      int pthread_cond_init (pthread_cond_t *cond,
      			      const pthread_condattr_t *attr);
          
      /**@fn            pthread_cond_signal
       * @brief         信号通知条件变量cond，唤醒一个等待者
       * @param[in]     pthread_cond_t *cond  待唤醒的条件变量
       * @param[out]    NONE
       * @description   常见错误码：[EINVAL] cond无效。
       * @return        int
      **/
      int pthread_cond_signal (pthread_cond_t *cond);
      	
      /**@fn            pthread_cond_broadcast
       * @brief         广播条件变量(唤醒所有等待该条件变量的线程,即等待者)
       * @param[in]     pthread_cond_t *cond 条件变量   
       * @param[out]    NONE
       * @description   常见错误码：[EINVAL] cond无效
       * @return        int
      **/
      int pthread_cond_broadcast (pthread_cond_t *cond);
      	
      /**@fn            pthread_cond_timedwait
       * @brief         等待条件变量被唤醒(等待条件变量cond被唤醒,直到由一个信号或广播，或绝对时间abstime到
       *				  才唤醒该线程)
       * @param[in]     pthread_cond_t *cond   条件变量 
       * @param[in]     pthread_mutex_t *mutex 互斥量 
       * @param[in]     const struct timespec *abstime 等待被唤醒的绝对超时时间  
       * @param[out]    NONE
       * @description   常见错误码：[EINVAL] 同时等待不同的互斥量；/cond,mutex/abstime无效；互斥量没有被主线程占有    
       *             	  [ETIMEDOUT] abstime指定绝对时间超时 
       * @return        int
      **/
      int pthread_cond_timedwait (pthread_cond_t  *cond,
      							pthread_mutex_t *mutex,
      							const struct timespec *abstime);
      	
      /**@fn            pthread_cond_wait
       * @brief         等待条件变量cond被唤醒(由一个信号或者广播)
       * @param[in]     pthread_cond_t *cond   条件变量 
       * @param[in]     pthread_mutex_t *mutex 互斥量 
       * @param[out]    NONE
       * @description   常见错误码：[EINVAL] cond或mutex无效, [EINVAL] 同时等待不同的互斥量 [EINVAL] 主调线程没有占有互斥量
       * @return        int
      **/	
      int pthread_cond_wait (pthread_cond_t *cond,
      					   pthread_mutex_t *mutex);
      
      /**@fn            pthread_cond_destroy
       * @brief         释放/销毁条件变量
       * @param[in]     pthread_cond_t *cond 待销毁的条件变量 
       * @param[out]    NONE
       * @description   常见错误码：[EBUSY] cond正在使用 [EINVAL]cond无效
       * @return        int
      **/	
      int pthread_cond_destroy (pthread_cond_t *cond)
      
      ```


## 内存管理

* [详见1](http://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247491042&idx=1&sn=6a27149508df23d5414d279feac1c304&chksm=972acc98a05d458e5a147f1fd8306ca4f384903ec5b18560b67b15849f43942e60563f0ce5bf&mpshare=1&scene=24&srcid=0321sCT49uCvhw9cMJGzFOic&sharer_sharetime=1616262001659&sharer_shareid=0722ed5128948b6436f8552f291f9b0b#rd)
* 虚拟内存
  * 虚拟内存技术是操作系统的一种扩容技术，它使得不同进程在运行过程中，它所看到的是**自己独自占有了当前系统的4G内存**。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 
  * 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，**实际上并不立即就把虚拟内存对应位置的程序数据和代码**（比如.text .data段）**拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好**（叫做存储器映射），**等到运行到对应的程序时，才会通过缺页异常，来拷贝数据**。
  * 还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常
  * 请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换
* **虚拟内存的好处**
  * 扩大地址空间
  * 内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改
  * 公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间
  * 当进程通信时，可采用虚存共享的方式实现
  * 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存
  * 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高
  * 在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片
* **虚拟内存的代价**
  * **虚存的管理需要建立很多数据结构(如页表等)，这些数据结构要占用额外的内存**
  * **虚拟地址到物理地址的转换，增加了指令的执行时间**
  * **页面的换入换出需要磁盘I/O，这是很耗时的**
  * 如果一页中只有一部分数据，会浪费内存
* 颠簸(thrashing)
  * 分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）
  * 当系统内核发现**可运行内存变少**时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果**Page-out频繁不断的发生**，直到当内核管理分页的时间超过运行程式的时间时，**系统效能会急剧下降**。这时的**系统已经运行非常慢或进入暂停状态**，这种状态亦被称作thrashing(颠簸)
  * 解决策略
    * 如果是因为页面置换策略失误，可以修改置换算法来解决这个问题
    * 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量
    * 否则，还剩下两个办法：1. 终止该进程；2. 增加物理内存容量
* TLB
  * TLB( Translation Look- aside buffer)**专门用于缓存内存中的页表项**，一般**在MMU单元内部**，页表一般存储在物理内存中。**当处理器要访问一个虚拟地址时，首先会在TLB中查询**。如果TLB表项中没有相应的表项，称为TLB Miss，那么就需要访问页表来计算出相应的物理地址。如果TLB表项中有相应的表项，那么直接从TLB表项中获取物理地址，称为TLB命中
* 缺页中断
  * 在请求分页系统中，可以**通过查询页表中的状态位来确定所要访问的页面是否存在于内存中**。每当所要访问的页面不在内存时(缓存不命中)，会产生一次缺页中断，此时**操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存**
  * 缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤
    * 保护CPU现场
    * 分析中断原因
    * 转入缺页中断处理程序进行处理
    * 恢复CPU现场，继续执行
  * 但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，**与一般的中断存在区别**
    * **在指令执行期间产生和处理缺页中断信号**
    * **一条指令在执行期间，可能产生多次缺页中断**
    * **缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令**

## Linux

### 基础知识

* 什么是Linux内核

  * Linux 系统的核心是内核。内核控制着计算机系统上的**所有硬件和软件**，在必要时分配硬件，并根据需要执行软件
    1. 系统内存管理
    2. 应用程序管理
    3. 硬件设备管理
    4. 文件系统管理

* [Linux的启动过程](https://www.runoob.com/linux/linux-system-boot.html)

  * **内核引导**：当计算机打开电源后，首先是**BIOS开机自检**，按照BIOS中设置的启动设备（通常是硬盘）来启动。操作系统接管硬件以后，首先读入 /boot 目录下的内核文件

  * **运行init**：init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 /etc/inittab

    * 运行级别
      * 许多程序需要开机启动。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。init进程的一大任务，就是去运行这些开机启动的程序。但是，**不同的场合需要启动不同的程序**，比如用作服务器时，需要启动Apache，用作桌面就不需要。
      * Linux允许为**不同的场合，分配不同的开机启动程序，这就叫做"运行级别"（runlevel）**。也就是说，启动时**根据"运行级别"，确定要运行哪些程序**
      * Linux系统有7个运行级别(runlevel)：
        - 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
        - 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
        - 运行级别2：多用户状态(没有NFS)
        - 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
        - 运行级别4：系统未使用，保留
        - 运行级别5：X11控制台，登陆后进入图形GUI模式
        - 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动

  * 系统初始化：在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：**激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务**

  * 建立终端：rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端

    ```shell
    1:2345:respawn:/sbin/mingetty tty1
    2:2345:respawn:/sbin/mingetty tty2
    3:2345:respawn:/sbin/mingetty tty3
    4:2345:respawn:/sbin/mingetty tty4
    5:2345:respawn:/sbin/mingetty tty5
    6:2345:respawn:/sbin/mingetty tty6
    ```

    从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。

  * 用户登录系统：一般来说，用户的登录方式有三种：

    - 命令行登录
    - ssh登录
    - 图形界面登录

  * 对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。**只有/etc/securetty中登记了的终端才允许 root 用户登录**，如果不存在这个文件，则 root 用户可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。

  * 图形模式与文字模式的切换方式

    * Linux预设提供了**六个命令窗口终端机让我们来登录**。
    * 默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们
    * 如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面
    * 当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了
    * 如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口


### [守护进程](https://blog.csdn.net/mijichui2153/article/details/81394387)

* 守护进程概念

  * 守护进程是**后台运行的**、**不与任何终端关联的(无法通过终端输入输出)**，用于**周期性地执行某种任务或等待处理特定的事件**

* 守护进程实现思路

  * **现一个守护进程，其实就是将普通进程按照上述特性改造为守护进程的过程。**需要注意的一点是，不同版本的 Unix 系统其实现机制不同，BSD 和 Linux 下的实现细节就不同

* 进程组和会话的概念

  * 进程组是**一组相关进程的集合**
  * 会话是**一组相关进程组的集合**

* 一个进程会有如下ID

  * PID：进程的唯一标识。对于多线程的进程而言，所有线程调用`getpid`函数会返回相同的值

  * PGID：进程组ID。每个进程都会有进程组ID，表示该进程所属的进程组。**默认情况下新创建的进程会继承父进程的进程组ID**

  * SID：会话ID。每个进程也都有会话ID。默认情况下，**新创建的进程会继承父进程的会话ID**

  * 可以调用以下函数获取/设置进程组ID跟会话ID

    ```c
    #include<unistd.h>
    #include<sys/types.h>
    pid_t getpgrp(void);
    pid_t getsid(pid_t pid); 
    int setpgid(pid_t pid, pid_t pgid); // 找到进程ID为pid的进程，将其进程组ID修改为pgid，如果pid的值为0，则表示要修改调用进程的进程组ID。该接口一般用来创建一个新的进程组
    
    pid_t setsid(void);  
    /*
    如果这个函数的调用进程不是进程组组长，那么调用该函数会发生以下事情：
    1）创建一个新会话，会话ID等于进程ID，调用进程成为会话的首进程。
    2）创建一个进程组，进程组ID等于进程ID，调用进程成为进程组的组长。
    3）该进程没有控制终端，如果调用setsid前，该进程有控制终端，这种联系就会断掉。
    调用setsid函数的进程不能是进程组的组长，否则调用会失败，返回-1，并置errno为EPERM。
    这个限制是比较合理的。如果允许进程组组长迁移到新的会话，而进程组的其他成员仍然在老的会话中，那么，就会出现同一个进程组的进程分属不同的会话之中的情况，这就破坏了进程组和会话的严格的层次关系了。
    */
    ```

* 创建后台进程步骤

  * **fork()创建子进程，父进程exit()退出**

    * 这是创建守护进程的第一步。**由于守护进程是脱离控制终端的，完成这一步后就会在Shell终端里造成程序已经运行完毕的假象**。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作
    * 由于父进程先于子进程退出，子进程就变为孤儿进程，并由` init `进程作为其父进程收养

  * **在子进程调用setsid()创建新会话**

    * 在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，**虽然父进程退出了，但会话期、进程组、控制终端等并没有改变。这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来**
    * setsid()创建一个新会话，**调用进程担任新会话的首进程**，其作用有
      * 使当前进程脱离原会话的控制
      * 使当前进程脱离原进程组的控制
      * 使当前进程脱离原控制终端的控制
    * 这样，当前进程才能实现真正意义上完全独立出来，摆脱其他进程的控制

  * **再次 fork() 一个子进程，父进程exit()退出**

    * 现在，进程已经成为无终端的会话组长，但它可以重新申请打开一个控制终端，可以通过 fork() 一个子进程，该子进程不是会话首进程，该进程将不能重新打开控制终端。退出父进程
    * 也就是说**通过再次创建子进程结束当前进程，使进程不再是会话首进程来禁止进程重新打开控制终端**

  * **在子进程中调用chdir()让根目录“/”成为子进程的工作目录**

    * 这一步也是**必要的步骤**。**使用fork创建的子进程继承了父进程的当前工作目录**。由于在进程运行中，当前目录所在的文件系统（如“/mnt/usb”）是不能卸载的，这对以后的使用会造成诸多的麻烦（比如系统由于某种原因要进入单用户模式）
    * 因此，通常的做法是让"/"作为守护进程的当前工作目录，这样就可以避免上述的问题，当然，如有特殊需要，也可以把当前工作目录换成其他的路径，如/tmp。改变工作目录的常见函数是chdir。(避免原父进程当前目录带来的一些麻烦)

  * **在子进程中调用umask()重设文件权限掩码为0**

    * 文件权限掩码是指**屏蔽掉文件权限中的对应位**。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限（就是说可读可执行权限均变为7）。**由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此把文件权限掩码重设为0即清除掩码（权限为777），这样可以大大增强该守护进程的灵活性**。通常的使用方法为umask(0)。(相当于把权限开发)

  * **在子进程中close()不需要的文件描述符**

    * 同文件权限码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下
    * 其实在上面的第二步之后，守护进程已经与所属的控制终端失去了联系。因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，**文件描述符为0、1和2 的3个文件（常说的输入、输出和报错）**已经失去了存在的价值，也应被关闭（关闭失去价值的输入、输出、报错等对应的文件描述符）

  * **守护进程退出处理**

    * 当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。所以，守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出

    * 想退出守护进程，只需给守护进程发送 SIGQUIT 信号即可

      ```shell
      sudo kill -3 PID 
      ```

* 步骤流程图

  <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/daemon.png" alt="daemon" style="zoom:80%;" />

* 代码实现

  ```c++
  #include<stdio.h>
  #include<fcntl.h>
  #include<sys/types.h>
  #include<unistd.h>
  #include<stdlib.h>
  
  void create_daemon()
  {
  	pid_t pid;
  	/*(1)-----创建一个进程来用作守护进程-----*/
  	pid = fork();
  	if(pid == -1){
  		printf("fork error\n");
  		exit(1);
  	}
  	/*(1.1)-----------原父进程退出-------------*/
  	else if(pid){
  		exit(0);
  	}
   	/*(2)---setsid使子进程独立。摆脱会话控制、摆脱原进程组控制、摆脱终端控制----*/
  	if(-1 == setsid()){
  		printf("setsid error\n");
  		exit(1);
  	}
    	/*(3)---通过再次创建子进程结束当前进程，使进程不再是会话首进程来禁止进程重新打开控制终端----*/
  	pid = fork();
  	if(pid == -1){
  		printf("fork error\n");
  		exit(1);
  	}
  	else if(pid){
  		exit(0);
  	}
    	/*(4)---子进程中调用chdir()让根目录成为子进程工作目录----*/
  	chdir("/");
      
      /*(5)---重设文件掩码为0（将权限全部开放）----*/
  	umask(0);
      
  	/*(6)---关闭文件描述符(常说的输入，输出，报错3个文件)----*/
  	for(int i = 0; i < 3; ++i){
  		close(i);
  	}
      // 将标准输入、标准输出、标准错误输出重定向到/dev/null文件
      open("/dev/null", O_RDONLY);
      open("/dev/null", O_RDWR);
      open("/dev/null", O_RDWR);
  	
  	return;
  }
  ```

* Linux提供了完成同样功能的库函数

  ```c++
  #include<unistd.h>
  int daemon(int nochdir, int noclose);
  // nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录被设置为"/"(根目录)，否则继续使用当前工作目录
  // noclose参数为0时，标准输入、标准输出、标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备
  // 成功返回0，失败返回-1并设置errno
  ```

### 系统监测

* CPU，内存，IO监控

  * **ps**命令用于显示当前进程的状态(cpu利用率， 占用内存，状态，运行时间等)，类似于 windows 的任务管理器

    ```shell
    ps [options] [--help]
    
    -A 列出所有的进程
    -w 显示加宽可以显示较多的资讯
    -au 显示较详细的资讯
    -aux 显示所有包含其他使用者的进程
    -ajx 获得当前所有的进程及父进程和进程组id
    -axjf/-ejH 查看所有进程的层次关系
    -ef 显示所有命令，连带命令行
    ```

    -aux 显示格式`USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND`

    * USER: 行程拥有者
    * PID: pid
    * %CPU: 占用的 CPU 使用率
    * %MEM: 占用的记忆体使用率
    * VSZ: 占用的虚拟记忆体大小
    * RSS: 占用的记忆体大小
    * TTY: 终端的次要装置号码 (minor device number of tty)
    * STAT: 该行程的状态:
      - D: 无法中断的休眠状态 (通常 IO 的进程)
      - R: 正在执行中
      - S: 静止状态
      - T: 暂停执行
      - Z: 不存在但暂时无法消除（僵尸进程）
      - W: 没有足够的记忆体分页可分配
      - <: 高优先序的行程
      - N: 低优先序的行程
      - L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
    * START: 行程开始时间
    * TIME: 执行的时间
    * COMMAND:所执行的指令

  * **vmstat**  可以展现给定时间间隔的服务器的状态值，包括服务器的**CPU使用率，内存使用，虚拟内存交换情况，IO读写情况**

    * 相比top，vmstat可以看到**整个机器**的CPU,内存,IO的使用情况，**而不是**单单看到**各个进程**的CPU使用率和内存使用率

    ```shell
    -a：显示活跃和非活跃内存
    -f：显示从系统启动至今的fork数量 。
    -m：显示slabinfo
    -n：只在开始时显示一次各字段名称。
    -s：显示内存相关统计信息及多种系统活动数量。
    delay：刷新时间间隔。如果不指定，只显示一条结果。
    count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。
    -d：显示磁盘相关统计信息。
    -p：显示指定磁盘分区统计信息
    -S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）
    -V：显示vmstat版本信息
    ```

  * **top** 实时监控系统状态，查看内存，端口 ，io访问量，读写速率

    ```shell
    top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]
    
    d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s
    q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行
    c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称
    S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来
    s : 安全模式，将交谈式指令取消, 避免潜在的危机
    i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程
    n : 更新的次数，完成后将会退出 top
    b : 批次档模式，搭配 "n" 参数一起使用，可以用来将 top 的结果输出到档案内
    ```

  * **mpstat** 实时监测多处理器系统上的**每个CPU的使用情况**

  * **iostat** 主要用于输出磁盘IO 和 CPU的统计信息

    ```shell
    iostat [选项] [<时间间隔>] [<次数>]
    
    -c： 显示CPU使用情况
    -d： 显示磁盘使用情况
    -N： 显示磁盘阵列(LVM) 信息
    -n： 显示NFS 使用情况
    -k： 以 KB 为单位显示
    -m： 以 M 为单位显示
    -t： 报告每秒向终端读取和写入的字符数和CPU的信息
    -V： 显示版本信息
    -x： 显示详细信息
    -p：[磁盘] 显示磁盘和分区的情况
    ```

  * **free命令用于显示内存状态**，显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等

    ```shell
    free [-bkmotV][-s <间隔秒数>]
    -b 　以Byte为单位显示内存使用情况。
    -k 　以KB为单位显示内存使用情况。
    -m 　以MB为单位显示内存使用情况。
    -h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有B = bytes
         K = kilos
         M = megas
         G = gigas
         T = teras
    -o 　不显示缓冲区调节列。
    -s<间隔秒数> 　持续观察内存使用状况。
    -t 　显示内存总和列。
    -V 　显示版本信息。
    ```

* 网络监控

  * **tcpdump root权限下使用的抓包工具，只能抓取流经本机的数据包**

    ```shell
    tcpdump [-adeflnNOpqStvx][-c<数据包数目>][-dd][-ddd][-F<表达文件>][-i<网络界面>][-r<数据包文件>][-s<数据包大小>][-tt][-T<数据包类型>][-vv][-w<数据包文件>][输出数据栏位]
    -a 尝试将网络和广播地址转换成名称。
    -c <数据包数目> 收到指定的数据包数目后，就停止进行倾倒操作。
    -d 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。
    -dd 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。
    -ddd 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。
    -e 在每列倾倒资料上显示连接层级的文件头。
    -f 用数字显示网际网络地址。
    -F<表达文件> 指定内含表达方式的文件。
    -i<网络界面> 使用指定的网络截面送出数据包。
    -l 使用标准输出列的缓冲区。
    -n 不把主机的网络地址转换成名字。
    -N 不列出域名。
    -O 不将数据包编码最佳化。
    -p 不让网络界面进入混杂模式。
    -q 快速输出，仅列出少数的传输协议信息。
    -r <数据包文件> 从指定的文件读取数据包数据。
    -s<数据包大小> 设置每个数据包的大小。
    -S 用绝对而非相对数值列出TCP关联数。
    -t 在每列倾倒资料上不显示时间戳记。
    -tt 在每列倾倒资料上显示未经格式化的时间戳记。
    -T <数据包类型> 强制将表达方式所指定的数据包转译成设置的数据包类型。
    -v 详细显示指令执行过程。
    -vv 更详细显示指令执行过程。
    -x 用十六进制字码列出数据包资料。
    -w <数据包文件> 把数据包数据写入指定的文件。
    ```

  * **netstat 用于显示网络状态**，可以打印本地网卡接口上的全部链接 路由表信息 网卡接口信息等

    ```shell
    -a或--all 显示所有连线中的Socket。
    -A<网络类型>或--<网络类型> 列出该网络类型连线中的相关地址。
    -c或--continuous 持续列出网络状态。
    -C或--cache 显示路由器配置的快取信息。
    -e或--extend 显示网络其他相关信息。
    -F或--fib 显示路由缓存。
    -g或--groups 显示多重广播功能群组组员名单。
    -h或--help 在线帮助。
    -i或--interfaces 显示网络界面信息表单。
    -l或--listening 显示监控中的服务器的Socket。
    -M或--masquerade 显示伪装的网络连线。
    -n或--numeric 直接使用IP地址，而不通过域名服务器。
    -N或--netlink或--symbolic 显示网络硬件外围设备的符号连接名称。
    -o或--timers 显示计时器。
    -p或--programs 显示正在使用Socket的程序识别码和程序名称。
    -r或--route 显示Routing Table。
    -s或--statistics 显示网络工作信息统计表。
    -t或--tcp 显示TCP传输协议的连线状况。
    -u或--udp 显示UDP传输协议的连线状况。
    -v或--verbose 显示指令执行过程。
    -V或--version 显示版本信息。
    -w或--raw 显示RAW传输协议的连线状况。
    -x或--unix 此参数的效果和指定"-A unix"参数相同。
    --ip或--inet 此参数的效果和指定"-A inet"参数相同。
    ```

  * **ifstat** 简单的网络流量监测工具

    ```shell
    -a 监测系统上的所有网卡接口
    -i 指定要监测的网卡接口
    -t 在每行输出信息前加上时间戳
    ```

  * **iptables 对Linux系统中通信的数据包进行一定的检测，达到防火墙的目的**

* **lsof**查看一个进程打开了哪些文件，文件被哪些进程使用

  ```shell
  -P 18400 （按照进程ID查看）
  -d type (按照FD的类型查看）
  -i 4 (查看进程打开的网络连接，使用IPV4协议）
  -i :80 (查看进程打开的网络连接，端口号为80）
  -i @127.0.0.1 (查看进程打开的网络连接，IP为127.0.0.1）
  lsof file-name：查看文件对应的进程
  ```

* **监测消息列表、共享内存和信号量的信息**

  * **ipcs**：用于报告Linux中进程间通信设施的状态

    ```shell
    ipcs [resource ...] [output-format]
    ipcs [resource] -i <id>
    选项：
    -i, --id <id>  打印由 id 标识的资源的详细信息
    -h, --help     显示此帮助并退出
    -V, --version  输出版本信息并退出
    资源选项:
    -m, --shmems      共享内存段
    -q, --queues      消息队列
    -s, --semaphores  信号量
    -a, --all         全部(默认)
    输出格式：
    -t, --time        显示附加、脱离和更改时间
    -p, --pid         显示 PID 的创建者和最后操作
    -c, --creator     显示创建者和拥有者
    -l, --limits      显示资源限制
    -u, --summary     显示状态摘要
        --human       以易读格式显示大小
    -b, --bytes       以字节数显示大小
    ```

  * **ipcrm**：删除一个或更多的消息队列、信号量集或者共享内存标识，同时会将与ipc对象相关链的数据也一起移除

    ```shell
    ipcrm [options]
    ipcrm <shm|msg|sem> <id> [...]
    
    -m, --shmem-id <id>        按 id 号移除共享内存段
    -M, --shmem-key <键>       按键值移除共享内存段
    -q, --queue-id <id>        按 id 号移除消息队列
    -Q, --queue-key <键>       按键值移除消息队列
    -s, --semaphore-id <id>    按 id 号移除信号量
    -S, --semaphore-key <键>  按键值移除信号量
    -a, --all[=<shm|msg|sem>]  全部移除
    -v, --verbose              解释正在进行的操作
    
    -h, --help     显示此帮助并退出
    -V, --version  输出版本信息并退出
    ```

* [**ulimit**](https://blog.csdn.net/FreeApe/article/details/101058393) 

  * shell内建指令，可用来控制shell执行程序的资源

  * 设置项仅在当前shell作用(类似`export`命令，永久生效可以写入相关配置文件)

  * 写入`~/.profile或~/.bashrc`**只对当前用户持久性生效**

  * 写入`/etc/security/limits.conf`可针对性配置，**系统级持久性生效**

    ```shell
    ulimit [-acdfHlmnpsStuv] [limit]
    
    -S   Set a soft limit for the given resource(设置软资源限制，设置后可以增加，但是不能超过硬资源设置)
    -H   Set a hard limit for the given resource(设置硬资源限制，一旦设置不能增加)
    
    -a   All current limits are reported(显示当前所有的 limit 信息). 
    -c   The maximum size of core files created(最大的 core 文件的大小， 以 blocks 为单位). 
    -d   The maximum size of a process's data segment(进程最大的数据段的大小，以 Kbytes 为单位). 
    -f   The maximum size of files created by the shell(default option,进程可以创建文件的最大值，以 blocks 为单位)
    -l   The maximum size that can be locked into memory(最大可加锁内存大小，以 Kbytes 为单位). 
    -m   The maximum resident set size(最大内存大小，以 Kbytes 为单位). 
    -n   The maximum number of open file descriptors(可以打开最大文件描述符的数量). 
    -p   The pipe buffer size(管道缓冲区的大小，以 Kbytes 为单位). 
    -s   The maximum stack size(线程栈大小，以 Kbytes 为单位). 
    -t   The maximum amount of cpu time in seconds(最大的 CPU 占用时间，以秒为单位). 
    -u   The maximum number of processes available to a single user(用户最大可用的进程数). 
    -v   The maximum amount of virtual memory available to the process(进程最大可用的虚拟内存，以 Kbytes 为单位).
    
    ulimit -a
        core file size          (blocks, -c) 0
        data seg size           (kbytes, -d) unlimited
        scheduling priority             (-e) 0
        file size               (blocks, -f) unlimited
        pending signals                 (-i) 7823
        max locked memory       (kbytes, -l) 64
        max memory size         (kbytes, -m) unlimited
        open files                      (-n) 1024
        pipe size            (512 bytes, -p) 8
        POSIX message queues     (bytes, -q) 819200
        real-time priority              (-r) 0
        stack size              (kbytes, -s) 8192
        cpu time               (seconds, -t) unlimited
        max user processes              (-u) 7823
        virtual memory          (kbytes, -v) unlimited
        file locks                      (-x) unlimited
    ```

* linux的fd数量限制查询

  * 所有进程允许打开的最大fd数量

  ```shell
  cat /proc/sys/fs/file-max   // 9223372036854775807
  ```

  * 所有进程已经打开的fd数量及允许的最大数量

  ```shell
  cat /proc/sys/fs/file-nr
  ```

  * 单个进程允许打开的最大fd数量

  ```shell
  ulimit -n
  ```

  * 单个进程（例如进程id为5454）已经打开的fd

  ```shell
  ls -l /proc/5454/fd/
  lsof -p 5454
  ```

### 编译调试

* C++进程内存分布

  ![mem_align](https://gitee.com/canqchen/cloudimg/raw/master/img/mem_align.png)

* ar, nm, ldd, readelf, objdump

  * ar：建立或修改备存文件，或是从备存文件中抽取文件

    ```shell
    ar[-dmpqrtx][cfosSuvV][a<成员文件>][b<成员文件>][i<成员文件>][备存文件][成员文件]
    必要参数：
    -d 　删除备存文件中的成员文件。
    -m 　变更成员文件在备存文件中的次序。
    -p 　显示备存文件中的成员文件内容。
    -q 　将文件附加在备存文件末端。
    -r 　将文件插入备存文件中。
    -t 　显示备存文件中所包含的文件。  # 常用
    -x 　自备存文件中取出成员文件。
    选项参数：
    a <成员文件> 　将文件插入备存文件中指定的成员文件之后。
    b <成员文件> 　将文件插入备存文件中指定的成员文件之前。
    c 　建立备存文件。
    f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。
    i <成员文件> 　将文件插入备存文件中指定的成员文件之前。
    o 　保留备存文件中文件的日期。
    s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。
    S 　不产生符号表。
    u 　只将日期较新文件插入备存文件中。
    v 　程序执行时显示详细的信息。
    V 　显示版本信息。
    ```

  * nm：nm用来列出目标文件的**符号表清单**

  * ldd
    * 首先ldd不是一个可执行程序，而只是一个shell脚本
    * ldd能够显示**可执行模块的dependency**，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等
    * ldd显示**可执行模块**的dependency的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现
    
  * **readelf**：一般用于查看**ELF格式的文件信息**，常见的文件如在Linux上的**可执行文件**，**动态库(*.so)或者静态库(*.a) 等包含ELF格式**的文件

    * **系统里的目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同**

    * ELF(Executable and Linking Format)**可执行可链接格式**是一种对象文件的格式，**用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西**。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF是构成众多xNIX系统的基础之一

      * ELF文件有三种类型：
        * **可重定位的对象文件**(Relocatable file) 由汇编器汇编生成的 .o 文件	
        * **可执行的对象文件**(Executable file) 可执行应用程序
        * **可被共享的对象文件**(Shared object file) 动态库文件，也即 .so 文件

      * 在Unix下使用**readelf命令来显示可执行程序的信息，功能与objdump相似，但是显示的更加具体**

    * ELF格式的文件在Linux系统下有.axf、 .bin、 .elf、 .o、 .prx、 .puff、 .ko、 .mod和.so等等

  * objdump是用来**显示目标文件相关信息**的

* **编译链接和载入**

  * 编译：将预处理生成的文件，经过语法分析、司法分析、语义分析、以及优化后编译成若干个目标模块。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言
  * 链接：由链接程序将编译后形成的**一组目标模块**以及他们所需要的**库函数**链接在一起，形成一个完整的**载入模型**。链接主要解决**模块间的相互引用问题**，分为**地址和空间分配**，**符号解析**和**重定位**几个步骤。**在编译阶段生成目标文件时，会暂时搁置这些外部引用**，而这些外部引用就是在链接时确定的，链接器在链接时，会**根据符号名称去相应模块中寻找对应的符号**，**待符号确定后，链接器会重写之前哪些未确定的符号的地址**，这个过程就是重定位
  * 载入：由载入程序将载入模块载入内存
  
* **动态链接和静态链接的区别**

  * 静态链接以一组可重定位目标文件为输入，文件由各种不同的代码和数据节组成，通过符号解析和重定位生成一个完全链接的可以加载和运行的可执行文件
  * 静态链接有一些明显的缺点，**一是如果需要更新一个库，需要重新编译和链接库文件**。二是对于一些标准的函数，**如果将这些代码复制到每个程序运行的文本段中，会对存储器的资源造成很大的浪费**
  * 共享库就是为解决静态链接问题而生，共享库是一个目标模块。在运行时，可以加载到任意存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接。共享库在unix下通常使用.so后缀，window下为dll
  * 共享库使用两种方式共享，一是一个库只有一个so文件，**所有引用该库的执行程序共享这个文件的代码和数据**。**二是一个共享库的.text节的一个副本可以被不同的进程共享**
  * 注意在整个程序的链接过程中，**链接器只是拷贝了一些重定位和符号信息**。**在程序加载（execve）时才会解析so文件中代码和数据的引用**

* **动态库和静态库的创建与使用**

  * 库的名字由 lib+name+后缀，静态库的后缀为.a 动态库的后缀为.so 

  * 动态库的创建步骤

    * 将.c文件全部编译为.o文件

    * 在Shell下输入命令，创建动态库：

      ```shell
      gcc -shared –fPIC –o libname.so sourcefile.c
      
      -shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件
      -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的
      ```

    * 使用动态库

      ```shell
      gcc -o file file.c -L. -lname
      
      -L.：表示要链接的库在当前目录中
      ```

    * **动态链接时、执行时搜索路径顺序**

      * 编译目标代码时，`-L`指定的动态库搜索路径
      * 环境变量`LD_LIBRARY_PATH`指定的动态库搜索路径
      * 配置文件`/etc/ld.so.conf`中指定的动态库搜索路径
      * 默认的动态库搜索路径`/lib`，`/usr/lib`

  * 静态库的创建步骤

    * 将.c文件全部编译为.o文件

    * 在Shell下输入命令，创建静态库： 

      ```shell
      ar rcs libname.a 目标文件1 目标文件2...
      ```

  * 使用静态库

    ```shell
     gcc  -o file file.c –L. -lname
     # -L 为静态库路径
     # -l 为是链接到库的名字（可以简写库的名字）
    ```

  * **静态库链接时搜索路径顺序**

    * ld会去找GCC命令中的参数`-L`
  * 再找gcc的环境变量`LIBRARY_PATH`
    
    * 再找内定目录 `/lib`，`/usr/lib`， `/usr/local/lib` 这是当初compile gcc时写在程序内的

* gcc和g++的异同

  * 均属于the GNU Compiler Collection，gcc是鼻祖，后来才有了g++

    ```c++
    g++ == gcc -xc++ -lstdc++ -shared-libgcc	// gcc后面两项都是链接选项，表示g++要相比gcc链接其他库函数
    ```

  * 不同

    * **g++会自动链接C++标准库**，比如algorithm，string，vector等

    * gcc会根据文件后缀(.c,.cpp)自动识别是C文件还是C++文件，g++均认为是C++文件

    * gcc编译C文件少很多宏定义，gcc编译C++会多一些宏定义

      ```c++
      #define __GXX_WEAK__ 1
      #define __cplusplus 1
      #define __DEPRECATED 1
      #define __GNUG__ 4
      #define __EXCEPTIONS 1
      #define __private_extern__ extern
      ```

* gdb调试基本命令

  * [详见1](https://blog.csdn.net/qq_26399665/article/details/81165684)
  * [详见2](https://blog.csdn.net/weixin_45596153/article/details/101453983)

* gdb调试多线程

  ```c++
  info threads //显示当前可调式的所有线程 
  thread ID //切换当前调试的线程为指定ID的线程
  thread apply all command //所以的线程都执行command命令
  thread apply ID1,ID2.... command  //指定线程执行command命令
  set scheduler-locking off|on|step： 
  	//在使用step或continue命令调试当前被调试线程的时候，其他线程也是同时执行的，如果我们只想要被调试的线程执行，而其他线程停止等待，那就要锁定要调试的线程，只让它运行。 
  	//off:不锁定任何线程，所有线程都执行。 
      //on:只有当前被调试的线程会执行。 
  　　 //step:阻止其他线程在当前线程单步调试的时候抢占当前线程。只有当next、continue、util以及finish的时候，其他线程才会获得重新运行的
  show scheduler-locking： 查看当前锁定线程的模式
  i threads 实现线程间切换
  ```

* gdb调试多进程

  ```c++
  // 设置方法
  set follow-fork-mode [parent][child] 
  set detach-on-fork [on|off]  
  // 查看上述两个属性的值
  show follow-fork-mode //查看系统默认的模式
  show detach-on-fork
  /* 
  	parent                   on               只调试主进程（GDB默认）
  	child                    on               只调试子进程
  	parent                   off              同时调试两个进程，gdb跟主进程，子进程block在fork位置
  	child                    off              同时调试两个进程，gdb跟子进程，主进程block在fork位置
  */
  
  // 查询正在调试的进程
  info inferiors  //查询正在调试的进程
  inferior 进程编号 // 切换调试的进程
  add-inferior [-copies n] [-exec executable] //添加新的调试进程
  detach inferior [进程编号] //释放掉 
  kill inferior [进程编号] 
  remove-inferior [进程编号] //删除该进程
  set schedule-multiple 
  set print interior-events on/off
  ```

* **Core dump(核心转储)概念及调试方法**

  * 程序由于各种异常或者bug导致在运行过程中异常退出或者中止，并且在满足一定条件下会产生一个叫core的文件，通常情况下，core文件会包含了程序运行时的**内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息**等，我们可以理解为是程序工作当前状态存储生成第一个文件，许多的程序出错的时候都会产生一个core文件，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决
  * **产生cored ump的几种情况**
    * 内存访问越界
    * 多线程程序使用了线程不安全的函数：应该使用**可重入的函数**
    * 多线程读写的数据未加锁保护：对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成coredump
    * 非法指针：使用空指针，随意使用指针转换
    * 堆栈溢出：不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误
  * `ulimit  -c` 可以设置core文件的大小，如果**这个值为0.则不会产生core文件**，这个**值太小，则core文件也不会产生**，因为core文件一般都比较大
  * 使用`ulimit  -c unlimited`来设置无限大，则**任意情况下都会产生core文件**
  * 控制core文件保存位置和文件名格式
    * echo "/var/core_log/core-%e-%p-%t" > /proc/sys/kernel/core_pattern，这是临时的，这个也是动态加载和生成的
    * 永久修改在/etc/sysctl.conf文件中，在该文件的最后加上两行：sysctl -w kernel.core_pattern=/var/core_log/core-%e-%t-%p 和kernel.core_uses_pid = 0，最后执行sysctl –p生效
    * 以下是参数列表:
      * %p - insert pid into filename 当前pid(进程id)
      * %u - insert current uid into filename 当前uid(用户id)
      * %g - insert current gid into filename 当前gid(用户组id)
      * %s - insert signal that caused the coredump into the filename 导致产生core的信号
      * %t - insert UNIX time that the coredump occurred into filename core文件生成时的unix时间
      * %h - insert hostname where the coredump happened into filename 主机名
      * %e - insert coredumping executable name into filename 导致产生core的命令名/文件名
  * 调试
    * gcc -o test -test.c -g
    * 运行程序./test，产生core文件在/var/core_log目录中
    * 进入/var/core_log，gdb调试core文件：gdb /path/test core-test-time-pid
    * gdb运行直到发生coredump，此时利用bt指令查看堆栈信息定位发生点

* [**内存泄漏调试方法**](https://blog.csdn.net/weixin_36343850/article/details/77856051)

  * 内存泄漏的概念
    * 内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是**应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费**
    * 内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的、大小任意的(内存块的大小可以在程序运行期决定)、使用完后必须显示释放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块。否则，这块内存就不能被再次被申请使用，我们就说这块内存泄漏了
  * 内存泄漏分类
    * 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak
    * 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定
    * 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

* **什么时候发生段错误？**

  * MMU在做逻辑地址到物理地址的转换时发生2次检查
    * 一，检查逻辑地址是否在某个已定义的内存映射区域，这一步通过和mm_struct中，mmap指针所记录的vm_area_struct链表中的每个每个节点所限定的虚拟内存区域比较实现。vm_area_struct结构中的vm_start和vm_end成员记录该节点所定义的虚拟内存区域的起始/结束地址（逻辑地址）。**如果要访问的地址不在任何一个区域中，则说明是一个非法的地址**。Linux在搜索vm_area_struct是，不是使用链表，而是使用树结构加速查找速度
    * 二，MMU得到该地址的页表项，检查页表项中的权限信息，如果**操作（读/写）与权限不符**，则触发保护异常(**使用野指针，试图修改字符串常量**等)

  * 上述两种操作**都会导致段错误**

* core文件中是什么，gdb调试core文件

  * **在一个程序崩溃时，它一般会在指定目录下生成一个core文件**。core文件**仅仅是一个内存映象(同时加上调试信息)，主要是用来调试的**。通过core文件调试步骤：
    * ulimit -c unlimted（**打开core，默认没有打开**）
    * 运行./a.out（编译的时候加调试选项-g） **死锁阻塞，Ctrl+\ 产生core dump**
    * gdb ./a.out core.xxx
    * thread apply all bt查看死锁位置

* **gdb调试死锁**

  * **借助 Core Dump**。在程序莫名其妙down掉了，此时操作系统会把当前的内存状况存储在一个core 文件中，通过查看core文件就可以直观的程序是因为什么而垮掉了。有时候程序down了, 但是core文件却没有生成，core文件的生成跟你当前系统的环境设置有关系, 可以用下面的语句设置一下, 然后再运行程序便会生成core文件

    ```c++
    ulimit -c unlimited
    ```

  * core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号

  * 在多线程调试中使用Core Dump：

    * 使用 kill 命令产生 core dump文件：kill -11 pid 产生core文件
    * 使用gdb工具打开core文件 gdb dead_lock_demo core
    * 打印堆栈信息 thread apply all bt

* 如何读取一个10G文件，cat一个10g文件会发生什么

  - 强行 cat 一个大文件会造成内存溢出，通常将**cat**命令和**split**命令混合使用。
  - 比如内存是250M， 那么将10G的文件切分成若干个250M的文件，然后文本查找

### 文件管理

* Linux目录结构

  ![dir](https://gitee.com/canqchen/cloudimg/raw/master/img/dir.png)

  * 常见目录说明：

    * /bin： 存放**二进制可执行文件**(ls,cat,mkdir等)，常用命令一般都在这里；
    * /etc： **存放系统管理和配置文件**；
    * /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；
    * **/usr **： 用于存放**系统应用程序**；
    * /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；
    * **/proc**： **虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息**。
      * 是一个**伪文件系统，它只存在内存当中，而不占用外存空间**。它以文件系统的方式为访问系统内核数据的操作提供接口。用户和应用程序可以通过 proc得到系统的信息，并**可以改变内核的某些参数**。**由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的**
    * /root： 超级用户（系统管理员）的主目录（特权阶级0）
    * /sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等
    * /dev： 用于存放设备文件
    * /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；
    * /boot： 存放用于系统引导时使用的各种文件；
    * **/lib **： 存放着和**系统运行相关的库文件** ；
    * /tmp： 用于存放各种临时文件，是公用的临时文件存储点；
    * /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说**各种服务的日志文件**（系统启动日志等）等；
    * /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。

* **文件类型：**

  ```shell
  -：表示普通文件
  d：表示目录文件
  b：表示块设备文件
  c：表示字符设备文件
  l：连接文件
  s：套接文件
  p：管道文件
  ```

* **目录或文件管理命令**

  * cd：改变目录

  * pwd：查看当前目录

  * ls：显示目录下的文件信息

    ```
    ls [-alrtAFR] [name...]
    
    -a 显示所有文件及目录 (. 开头的隐藏文件也会列出)
    -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出
    -r 将文件以相反次序显示(原定依英文字母次序)
    -t 将文件依建立时间之先后次序列出
    -A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)
    -F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"
    -R 若目录下有文件，则以下之文件亦皆依序列出
    ```

  * mkdir：创建空白目录

    ```
    mkdir [-p] dirName
    
    -p：递归创建，可创建上一层没有的目录
    -m：创建目录时直接配置目录的权限
    ```

  * touch：用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件

    ```
    touch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]
    
    a 改变档案的读取时间记录。
    m 改变档案的修改时间记录。
    c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。
    f 不使用，是为了与其他 unix 系统的相容性而保留。
    r 使用参考档的时间记录，与 --file 的效果一样。
    d 设定时间与日期，可以使用各种不同的格式。
    t 设定档案的时间记录，格式与 date 指令相同。
    --no-create 不会建立新档案。
    --help 列出指令格式。
    --version 列出版本讯息。
    ```

  * cp：复制文件或目录

    ```
    cp [options] source dest
    cp [options] source... directory
    
    -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
    -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。
    -f：覆盖已经存在的目标文件而不给出提示。
    -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答"y"时目标文件将被覆盖。
    -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
    -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
    -l：不复制文件，只是生成链接文件。
    ```

  * mv：用来为文件或目录改名、或将文件或目录移入其它位置

    ```
    mv [options] source dest
    mv [options] source... directory
    
    -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。
    -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。
    -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。
    -n: 不要覆盖任何已存在的文件或目录。
    -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
    ```

  * rm：移除文件或目录

    ```
    rm [options] name...
    
    -i 删除前逐一询问确认。
    -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。
    -r 将目录及以下之档案亦逐一删除。
    ```

* **文件查看命令**

  * cat/tac：用于连接文件并打印到标准输出设备上，一个正向显示一个反向显示

    ```
    cat [-AbeEnstTuv] [--help] [--version] fileName
    
    -n 或 --number：由 1 开始对所有输出的行数编号。
    -b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。
    -s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。
    -v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。
    -E 或 --show-ends : 在每行结束处显示 $。
    -T 或 --show-tabs: 将 TAB 字符显示为 ^I。
    -A, --show-all：等价于 -vET。
    -e：等价于"-vE"选项；
    -t：等价于"-vT"选项；
    ```

  * more：类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h

    ```
    more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]
    
    -num 一次显示的行数
    -d 提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声
    -l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能
    -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）
    -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容
    -c 跟 -p 相似，不同的是先显示内容再清除其他旧资料
    -s 当遇到有连续两行以上的空白行，就代换为一行的空白行
    -u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）
    +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示
    +num 从第 num 行开始显示
    fileNames 欲显示内容的文档，可为复数个数
    ```

  * less：与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页

    ```
    less [参数] 文件 
    
    -b <缓冲区大小> 设置缓冲区的大小
    -e 当文件显示结束后，自动离开
    -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件
    -g 只标志最后搜索的关键词
    -i 忽略搜索时的大小写
    -m 显示类似more命令的百分比
    -N 显示每行的行号
    -o <文件名> 将less 输出的内容在指定文件中保存起来
    -Q 不使用警告音
    -s 显示连续空行为一行
    -S 行过长时间将超出部分舍弃
    -x <数字> 将"tab"键显示为规定的数字空格
    /字符串：向下搜索"字符串"的功能
    ?字符串：向上搜索"字符串"的功能
    n：重复前一个搜索（与 / 或 ? 有关）
    N：反向重复前一个搜索（与 / 或 ? 有关）
    b 向上翻一页
    d 向后翻半页
    h 显示帮助界面
    Q 退出less 命令
    u 向前滚动半页
    y 向前滚动一行
    空格键 滚动一页
    回车键 滚动一行
    [pagedown]： 向下翻动一页
    [pageup]： 向上翻动一页
    ```

  * head：可用于查看文件的开头部分的内容，有一个常用的参数 **-n** 用于显示行数，默认为 10，即显示 10 行的内容

    ```
    head [参数] [文件] 
    
    -q 隐藏文件名
    -v 显示文件名
    -c<数目> 显示的字节数
    -n<行数> 显示的行数
    ```

  * tail：可用于查看文件的内容，有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。**tail -f filename** 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容

    ```
    tail [参数] [文件] 
    
    -f 循环读取
    -q 不显示处理信息
    -v 显示详细的处理信息
    -c<数目> 显示的字节数
    -n<行数> 显示文件的尾部 n 行内容
    --pid=PID 与-f合用,表示在进程ID,PID死掉之后结束
    -q, --quiet, --silent 从不输出给出文件名的首部
    -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒
    ```

  * tr：用于替换文本文件中的字符

    ```
    tr [-cdst][--help][--version][第一字符集][第二字符集]  
    tr [OPTION]…SET1[SET2] 
    
    -c, --complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换
    -d, --delete：删除指令字符
    -s, --squeeze-repeats：缩减连续重复的字符成指定的单个字符
    -t, --truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等
    --help：显示程序用法信息
    --version：显示程序本身的版本信息
    
    字符集合的范围：
    \NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)
    \\ 反斜杠
    \a Ctrl-G 铃声
    \b Ctrl-H 退格符
    \f Ctrl-L 走行换页
    \n Ctrl-J 新行
    \r Ctrl-M 回车
    \t Ctrl-I tab键
    \v Ctrl-X 水平制表符
    CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。
    [CHAR*] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止
    [CHAR*REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)
    [:alnum:] ：所有字母字符与数字
    [:alpha:] ：所有字母字符
    [:blank:] ：所有水平空格
    [:cntrl:] ：所有控制字符
    [:digit:] ：所有数字
    [:graph:] ：所有可打印的字符(不包含空格符)
    [:lower:] ：所有小写字母
    [:print:] ：所有可打印的字符(包含空格符)
    [:punct:] ：所有标点字符
    [:space:] ：所有水平与垂直空格符
    [:upper:] ：所有大写字母
    [:xdigit:] ：所有 16 进位制的数字
    [=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)
    ```

  * wc：用于统计文本的行数、字数、字节数

    ```
    wc [-clw][--help][--version][文件...]
    
    -c或--bytes或--chars 只显示Bytes数。
    -l或--lines 显示行数。
    -w或--words 只显示字数。
    --help 在线帮助。
    --version 显示版本信息。
    
    在默认的情况下，wc将计算指定文件的行数、字数，以及字节数
    ```

* **打包压缩**

  * tar：用于对文件进行打包或解压

    ```
     tar [打包文件名称] [要打包的目录]
     
    -c：创建压缩文件
    -x：解开压缩文件
    -t：查看压缩包内有哪些文件
    -z：用Gzip压缩或解压
    -j：用bzip2压缩或解压
    -v：显示解压或压缩过程
    -f：目标文件名
    -P：保留原始的权限和属性
    -p：使用绝对路径压缩
    -C：指定解压到的目录
    
    压缩文件：tar -czvf file... target.tar.gz
    解压文件：tar -xzvf target.tar.gz
    ```

* 搜索

  * **find** 命令：主要用于查找文件

    ```shell
    find path -option [-print] [-exec -ok command ] {} \;
    
    -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件
    -amin n : 在过去 n 分钟内被读取过
    -anewer file : 比文件 file 更晚被读取过的文件
    -atime n : 在过去n天内被读取过的文件
    -cmin n : 在过去 n 分钟内被修改过
    -cnewer file :比文件 file 更新的文件
    -ctime n : 在过去n天内被修改过的文件
    -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name
    -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写
    -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写
    -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。
    -type c : 文件类型是 c 的文件。d: 目录，c: 字型装置文件，b: 区块装置文件，p: 具名贮列，f: 一般文件，l: 符号连结，s: socket
    -pid n : process id 是 n 的文件
    ```

    - 实例

      - 将当前目录及其子目录下所有文件后缀为 **.c** 的文件列出来

        ```shell
        find . -name "*.c"
        ```

      - 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们

        ```shell
        find /var/log -type f -mtime +7 -ok rm {} \;
        ```

      - 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件

        ```shell
        find . -type f -perm 644 -exec ls -l {} \;
        ```

* 过滤查找

  * **grep**：强大的文本搜索工具，主要用来在某个文件中**查找具体文字内容**

    ```shell
    grep [-abcEFGhHilLnqrsvVwxy][-A<显示行数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]
    
    -a 或 --text : 不要忽略二进制的数据。
    -A<显示行数> 或 --after-context=<显示行数> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
    -b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
    -B<显示行数> 或 --before-context=<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前的内容。
    -c 或 --count : 计算符合样式的列数
    -C<显示行数> 或 --context=<显示行数>或-<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。
    -d <动作> 或 --directories=<动作> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
    -e<范本样式> 或 --regexp=<范本样式> : 指定字符串做为查找文件内容的样式。
    -E 或 --extended-regexp : 将样式为延伸的正则表达式来使用。
    -f<规则文件> 或 --file=<规则文件> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
    -F 或 --fixed-regexp : 将样式视为固定字符串的列表。
    -G 或 --basic-regexp : 将样式视为普通的表示法来使用。
    -h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。
    -H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。
    -i 或 --ignore-case : 忽略字符大小写的差别。
    -l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。
    -L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。
    -n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。
    -o 或 --only-matching : 只显示匹配PATTERN 部分。
    -q 或 --quiet或--silent : 不显示任何信息。
    -r 或 --recursive : 此参数的效果和指定"-d recurse"参数相同。
    -s 或 --no-messages : 不显示错误信息。
    -v 或 --invert-match : 显示不包含匹配文本的所有行。
    -V 或 --version : 显示版本信息。
    -w 或 --word-regexp : 只显示全字符合的列。
    -x --line-regexp : 只显示全列符合的列。
    -y : 此参数的效果和指定"-i"参数相同。
    ```

    - 实例

      - 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行

        ```shell
        grep test *file 
        ```

      - 递归查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串"update"的文件，并打印出该字符串所在行的内容

        ```shell
        grep -r update /etc/acpi
        ```

      - 反向查找。前面各个例子是查找并打印出符合条件的行，通过"-v"参数可以打印出不符合条件行的内容

        ```shell
        grep -v test *test*
        ```

* sed，awk

  - sed：实现数据的**替换，删除，增加，选取**等(以**行为单位**进行处理)

  - awk: 以**字段为单位进行处理**(其实就是把一行的数据分割，然后进行处理)

* 文件储存原理

  * 文件储存在硬盘上，硬盘的**最小存储单位叫做"扇区"**（Sector）。**每个扇区储存512字节**（相当于0.5KB）。
  * 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是**文件存取的最小单位**。**"块"的大小，最常见的是4KB**，即**连续八个 sector组成一个 block**。
  * 文件数据都储存在"块"中，那么很显然，我们还必须**找到一个地方储存文件的元信息**，比如**文件的创建者、文件的创建日期、文件的大小**等等。**这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"**。

* inode概念

  * 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息

* inode内容

  * 文件的字节数
  * 文件拥有者的User ID
  * 文件的Group ID
  * 文件的读、写、执行权限
  * 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间
  * 链接数，即有多少文件名指向这个inode
  * 文件数据block的位置

* 可以用`stat`命令，查看某个文件的inode信息：`stat filename`

* inode的大小

  * inode也会消耗硬盘空间，所以硬盘格式化的时候，**操作系统自动将硬盘分成两个区域**。一个是**数据区**，存放文件数据；另一个是**inode区**（inode table），存放**inode所包含的信息**
  * 每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是**每1KB或每2KB就设置一个inode**。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。
  * 查看每个硬盘分区的inode总数和已经使用的数量，可以使用`df`命令：`df -i`
  * 查看每个inode节点的大小，可以用：`sudo dumpe2fs -h /dev/hda | grep "Inode size"`
  * 由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件

* **inode号码**

  * 每个inode都有一个号码，操作系统用inode号码来识别不同的文件
  * 这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号
  * 表面上，用户通过文件名，打开文件。实际上，系统内部这个过程**分成三步**：首先，**系统找到这个文件名对应的inode号码**；其次，**通过inode号码，获取inode信息**；最后，**根据inode信息，找到文件数据所在的block，读出数据**
  * 查看文件名对应的inode号码：`ls -i filename`

* **目录文件**

  * Unix/Linux系统中，目录（directory）也是一种文件。**打开目录，实际上就是打开目录文件**
  * 目录文件的结构非常简单，就是一系列目录项（dirent）的列表。**每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码**
  * 列出整个目录文件，即文件名和inode号码：`ls -i dir`
  * 要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。`ls -l`命令列出文件的详细信息
  * 目录权限
    * 理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身，即**不同用户能以什么权限访问操作对该目录文件**。
    * 例如这里不同用户对tmp目录文件（d可以查出tmp是目录文件，d表示directory，即目录）分别为rwxr-xr-x，第一组的三个字符，即rwx，表示文件拥有者用户的对该文件的读写权限，第二组的三个字符，即r-x，表示文件拥有者用户所在的用户组里的其他用户对该文件的读写权限，第三组的三个字符，即r-x，表示文件拥有者用户所在的用户组以外的用户对该文件的读写权限。一个某个用户下运行的进程访问操作该目录文件只能以该用户所具有的对该目录文件的权限进行操作
    * 由于目录文件内**只有文件名和inode号码**，所以**如果只有读权限，只能获取文件名**，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）

* 硬链接

  * 一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名
  * **但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。**
  * ln命令可以创建硬链接：`ln sourcefile destfile`
  * 运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。**inode信息中有一项叫做"链接数"，记录指向该inode的文件名总数，**这时就会增加1。
  * **反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。**
  * 这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2（某一目录的目录名和该目录的当前目录名）

* 软连接

  * 除了硬链接以外，还有一种特殊情况
  * **文件A和文件B的inode号码虽然不一样**，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）
  * 这意味着，**文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错**："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。
  * ln -s命令可以创建软链接：`ln -s sourcefile destfile`

* **inode的特殊作用**

  * 由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象
    * 有时，**文件名包含特殊字符，无法正常删除**。这时，**直接删除inode节点，就能起到删除文件的作用**
    * **移动文件或重命名文件，只是改变文件名，不影响inode号码**
    * 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名
  * 第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收

### 零拷贝技术

* 概念

  * **零拷贝（ zero-copy ）**技术可以有效地改善数据传输的性能，在内核驱动程序（比如网络堆栈或者磁盘存储驱动程序）处理 I/O 数据的时候，零拷贝技术可以在某种程度上减少甚至完全避免不必要 CPU 数据拷贝操作。
  * **零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术**。**针对操作系统中的设备驱动程序、文件系统以及网络协议堆栈而出现的各种零拷贝技术极大地提升了特定应用程序的性能，并且使得这些应用程序可以更加有效地利用系统资源**。这种性能的提升就是**通过在数据拷贝进行的同时，允许 CPU 执行其他的任务来实现的**
  * 概括如下
    * **避免数据拷贝**
      * **避免操作系统内核缓冲区之间进行数据拷贝操作**
      * **避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作**
      * **用户应用程序可以避开操作系统直接访问硬件存储**
      * **数据传输尽量让 DMA 来做**
    * **综合目标**
      * **避免不必要的系统调用和上下文切换**
      * 需要拷贝的数据可以先被缓存起来
      * 对数据进行处理尽量让硬件来做

* 零拷贝使用场景

  * 在写一个服务端程序时（Web Server或者文件服务器），文件下载是一个基本功能。这时候服务端的任务是：将服务端主机磁盘中的文件不做修改地从已连接的socket发出去，我们通常用下面的代码完成：

    ```c++
    while((n = read(diskfd, buf, BUF_SIZE)) > 0)
       write(sockfd, buf , n);
    ```

  * 基本操作就是循环的从磁盘读入文件内容到缓冲区，再将缓冲区的内容发送到socket。但是由于Linux的I/O操作默认是缓冲I/O。这里面主要使用的也就是read和write两个系统调用，我们并不知道操作系统在其中做了什么。实际上在以上I/O操作中，发生了多次的数据拷贝。

  * 当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区中去。如果不是，**操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠DMA来传输**，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。接下来，write系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后socket再把内核缓冲区的内容发送到网卡上

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/multi_copy.png" alt="multi_copy" style="zoom:80%;" />

  * 从上图中可以看出，共产生了**两次系统调用，四次数据拷贝**，即使使用了DMA来处理了与硬件的通讯，CPU仍然需要处理两次数据拷贝，与此同时，在用户态与内核态也发生了多次上下文切换，无疑也加重了CPU负担。在此过程中，我们没有对文件内容做任何修改，那么在内核空间和用户空间来回拷贝数据无疑就是一种浪费，而零拷贝主要就是为了解决这种低效性

  * 零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效

* 零拷贝技术使用

  * **使用mmap**

    * 减少拷贝次数的一种方法是调用mmap()来代替read调用：

      ```c++
      buf = mmap(diskfd, len);
      write(sockfd, buf, len);
      ```

    * 应用程序调用mmap()，**磁盘上的数据会通过DMA被拷贝的内核缓冲区**，**接着操作系统会把这段内核缓冲区与应用程序共享**，**这样就不需要把内核缓冲区的内容往用户空间拷贝**。应用程序**再调用write()**，**操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中**，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/mmap.png" alt="mmap" style="zoom:80%;" />

  * 使用mmap替代read很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。**但是使用mmap是有代价的。当你使用mmap时，你可能会遇到一些隐藏的陷阱。例如，当你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止**。SIGBUS信号默认会杀死你的进程并产生一个coredump,如果你的服务器这样被中止了，那会产生一笔损失。通常可以使用以下解决方案避免这种问题：

    * **为SIGBUS信号建立信号处理程序**

      * 当遇到SIGBUS信号时，信号处理程序简单地返回，write系统调用在被中断之前会返回已经写入的字节数，并且errno会被设置成success，但是这是一种糟糕的处理办法，因为你并没有解决问题的实质核心

    * **使用文件租借锁**

      * 通常我们使用这种方法，在**文件描述符上使用租借锁**，我们为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的`RT_SIGNAL_LEASE`信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被SIGBUS杀死之前，你的write系统调用会被中断。write会返回已经写入的字节数，并且置errno为success。我们应该在mmap文件之前加锁，并且在操作完文件后解锁：

        ```c++
        if(fcntl(diskfd, F_SETSIG, RT_SIGNAL_LEASE) == -1) {
            perror("kernel lease set signal");
            return -1;
        }
        /* l_type can be F_RDLCK F_WRLCK  加锁*/
        /* l_type can be  F_UNLCK 解锁*/
        if(fcntl(diskfd, F_SETLEASE, l_type)){
            perror("kernel lease set type");
            return -1;
        }
        ```

* 使用sendfile

  * sendfile原型

    ```c++
    #include<sys/sendfile.h>
    ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
    ```

  * 系统调用`sendfile()`在代表输入文件的描述符`in_fd`和代表输出文件的描述符`out_fd`之间传送文件内容（字节）。描述符`out_fd`**必须指向一个套接字**，而`in_fd`**指向的文件必须是可以**`mmap`的。这些局限限制了sendfile的使用，**使sendfile只能将数据从文件传递到套接字上**，反之则不行。使用sendfile不仅**减少了数据拷贝的次数(1次)**，**还减少了上下文切换(一次调用，两次切换)**，**数据传送始终只发生在kernel space**

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/sendfile.png" alt="sendfile" style="zoom:80%;" />

  * 在调用sendfile时，如果有其它进程截断了文件会发生什么呢？假设我们没有设置任何信号处理程序，**sendfile调用仅仅返回它在被中断之前已经传输的字节数，errno会被置为success**。如果我们在调用sendfile之前给文件加了锁，sendfile的行为仍然和之前相同，我们还会收RT_SIGNAL_LEASE的信号

  * sendfile仍然存在一次拷贝，就是页缓存到socket缓存的拷贝。现在我们仅仅需要把**缓冲区描述符传到socket缓冲区，再把数据长度传过去，这样DMA控制器直接将页缓存中的数据打包发送到网络中就可以了**

    <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/zero_sendfile.png" alt="zero_sendfile" style="zoom:80%;" />

    * sendfile系统调用利用DMA引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，**DMA引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝**

    * 不过这一种收集拷贝功能是需要硬件以及驱动程序支持的。**需要网卡支持 SG-DMA**（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同）

    * 可以在 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：

      ```shell
      $ ethtool -k eth0 | grep scatter-gather
      scatter-gather: on
      ```

* 使用splice

  * sendfile只适用于将数据**从文件拷贝到套接字**上，限定了它的使用范围。Linux在2.6.17版本引入splice系统调用，用于**在两个文件描述符中移动数据**

  * 原型

    ```c++
      #define _GNU_SOURCE         /* See feature_test_macros(7) */
      #include <fcntl.h>
      ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);
    ```

      * splice调用在**两个文件描述符之间移动数据**，而**不需要数据在内核空间和用户空间来回拷贝**。他从`fd_in`拷贝`len`长度的数据到`fd_out`，**但是有一方必须是管道设备，这也是目前splice的一些局限性**。如果`fd_in`是一个管道文件描述符，那么off_in必须设为NULL；如果不是，那么表示从输入数据流的何处开始读取数据，此时若`fd_in`为NULL，则表示从输入数据流的当前偏移位置读入；不为NULL，则指出具体的偏移位置。``fd_out/off_out`同理使用与于输出流。flags参数有以下几种取值
      * SPLICE_F_MOVE ：尝试去移动数据而不是拷贝数据。这仅仅是对内核的一个小提示：**如果内核不能从pipe移动数据或者pipe的缓存不是一个整页面，仍然需要拷贝数据**。Linux最初的实现有些问题，**所以从2.6.21开始这个选项不起作用**，后面的Linux版本应该会实现
      * SPLICE_F_NONBLOCK ：splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞
      * SPLICE_F_MORE： 后面的splice调用会有更多的数据。

  * splice调用利用了Linux提出的**管道缓冲区机制**， 所以**至少一个描述符要为管道**。以上几种零拷贝技术都是**减少数据在用户空间和内核空间拷贝技术实现的**，**但是有些时候，数据必须在用户空间和内核空间之间拷贝**。这时候，我们只能**针对数据在用户空间和内核空间拷贝的时机上下功夫了**。**Linux通常利用写时复制(copy on write)来减少系统开销，这个技术又时常称作COW**

* 使用tee

  * tee函数用于**两个管道之间复制数据**，也是零拷贝操作，它不消耗数据，源文件描述符上面的数据仍然可以用于后续读操作

  * 原型

    ```c++
    #include <fcntl.h>
    ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);
    ```

  * 上述参数与splice相同，但fd_in和fd_out都必须是管道文件描述符。成功返回两个文件描述符之间复制的数据，返回0表示没任何数据复制，失败返回-1并设置errno